<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>synth &#8212; TuLiP 1.4.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../_static/classic.css?v=ff85e404" />
    <link rel="stylesheet" type="text/css" href="../_static/patch.css?v=0ad0caba" />
    
    <script src="../_static/documentation_options.js?v=350a9c04"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">TuLiP 1.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">synth</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for synth</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2012-2015 by California Institute of Technology</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions</span>
<span class="c1"># are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#    documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. Neither the name of the California Institute of Technology nor</span>
<span class="c1">#    the names of its contributors may be used to endorse or promote</span>
<span class="c1">#    products derived from this software without specific prior</span>
<span class="c1">#    written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH</span>
<span class="c1"># OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="c1"># SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
<span class="c1"># USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<span class="c1"># ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="c1"># OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
<span class="c1"># OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span class="c1"># SUCH DAMAGE.</span>
<span class="sd">&quot;&quot;&quot;Interface to library of synthesis tools, e.g., `gr1c`, `omega`.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">collections.abc</span> <span class="k">as</span> <span class="nn">_abc</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">_ty</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">_nx</span>

<span class="kn">import</span> <span class="nn">tulip.interfaces.gr1c</span> <span class="k">as</span> <span class="nn">gr1c</span>
<span class="kn">import</span> <span class="nn">tulip.interfaces.gr1py</span> <span class="k">as</span> <span class="nn">gr1py</span>
<span class="kn">import</span> <span class="nn">tulip.interfaces.omega</span> <span class="k">as</span> <span class="nn">omega_int</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">tulip.interfaces.slugs</span> <span class="k">as</span> <span class="nn">slugs</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">slugs</span> <span class="o">=</span> <span class="kc">None</span>
<span class="kn">import</span> <span class="nn">tulip.spec</span> <span class="k">as</span> <span class="nn">_spec</span>
<span class="kn">import</span> <span class="nn">tulip.transys</span> <span class="k">as</span> <span class="nn">transys</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;mutex&#39;</span><span class="p">,</span>
    <span class="s1">&#39;exactly_one&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sys_to_spec&#39;</span><span class="p">,</span>
    <span class="s1">&#39;env_to_spec&#39;</span><span class="p">,</span>
    <span class="s1">&#39;build_dependent_var_table&#39;</span><span class="p">,</span>
    <span class="s1">&#39;synthesize_many&#39;</span><span class="p">,</span>
    <span class="s1">&#39;synthesize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;is_realizable&#39;</span><span class="p">,</span>
    <span class="s1">&#39;strategy2mealy&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mask_outputs&#39;</span><span class="p">,</span>
    <span class="s1">&#39;determinize_machine_init&#39;</span><span class="p">]</span>


<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">_hl</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="mi">60</span> <span class="o">*</span> <span class="s1">&#39;-&#39;</span>


<span class="n">Formulas</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
<span class="n">Solver</span> <span class="o">=</span> <span class="n">_ty</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span>
    <span class="s1">&#39;gr1c&#39;</span><span class="p">,</span>
    <span class="s1">&#39;gr1py&#39;</span><span class="p">,</span>
    <span class="s1">&#39;omega&#39;</span><span class="p">,</span>
    <span class="s1">&#39;slugs&#39;</span><span class="p">,</span>
    <span class="p">]</span>
<span class="n">maybe_mealy</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span> <span class="o">|</span>
    <span class="kc">None</span><span class="p">)</span>
<span class="n">maybe_fts</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">transys</span><span class="o">.</span><span class="n">FTS</span> <span class="o">|</span>
    <span class="kc">None</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pstr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s1">)&#39;</span>


<span class="k">def</span> <span class="nf">_disj</span><span class="p">(</span><span class="n">set0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="s1">&#39; || &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
        <span class="n">_pstr</span><span class="p">,</span> <span class="n">set0</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_conj</span><span class="p">(</span><span class="n">set0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">nonempty</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">set0</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
        <span class="n">_pstr</span><span class="p">,</span> <span class="n">nonempty</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_conj_intersection</span><span class="p">(</span>
        <span class="n">set0</span><span class="p">,</span>
        <span class="n">set1</span><span class="p">,</span>
        <span class="n">parenth</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">conjuncts</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
        <span class="n">set1</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">,</span>
        <span class="n">set0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parenth</span><span class="p">:</span>
        <span class="n">conjuncts</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="n">_pstr</span><span class="p">,</span> <span class="n">conjuncts</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conjuncts</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_conj_neg</span><span class="p">(</span>
        <span class="n">set0</span><span class="p">,</span>
        <span class="n">parenth</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">parenth</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="sa">f</span><span class="s1">&#39;!(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">set0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
            <span class="sa">f</span><span class="s1">&#39;!</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">set0</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_conj_neg_diff</span><span class="p">(</span>
        <span class="n">set0</span><span class="p">,</span>
        <span class="n">set1</span><span class="p">,</span>
        <span class="n">parenth</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">x</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set1</span><span class="p">,</span>
        <span class="n">set0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parenth</span><span class="p">:</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_pstr</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">&#39; &amp;&amp; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;!</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">items</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">mutex</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mutual exclusion for all time.&quot;&quot;&quot;</span>
    <span class="n">iterable</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">_conj</span><span class="p">([</span>
        <span class="sa">f</span><span class="s1">&#39;!(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">) || (</span><span class="si">{</span><span class="n">_conj_neg_diff</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">])</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">])]</span>


<span class="k">def</span> <span class="nf">exactly_one</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;N-ary xor.</span>

<span class="sd">    Contrast with pure mutual exclusion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">iterable</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
            <span class="n">_pstr</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">conjoin</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_conj_neg_diff</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span>
    <span class="k">def</span> <span class="nf">formula</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">) &amp;&amp; </span><span class="si">{</span><span class="n">conjoin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="n">disjunction</span> <span class="o">=</span> <span class="n">_disj</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">formula</span><span class="p">,</span> <span class="n">iterable</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">disjunction</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_conj_action</span><span class="p">(</span>
        <span class="n">actions_dict</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">action_type</span><span class="p">:</span>
            <span class="n">_abc</span><span class="o">.</span><span class="n">Hashable</span><span class="p">,</span>
        <span class="n">nxt</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ids</span><span class="p">:</span>
            <span class="nb">dict</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return conjunct if `action_type` in `actions_dict`.</span>

<span class="sd">    @param actions_dict:</span>
<span class="sd">        `dict` with pairs `action_type_name : action_value`</span>
<span class="sd">    @param action_type:</span>
<span class="sd">        key to look for in `actions_dict`</span>
<span class="sd">        (here typically a str)</span>
<span class="sd">    @param nxt:</span>
<span class="sd">        prepend or not with the next operator</span>
<span class="sd">    @param ids:</span>
<span class="sd">        map `action_value` -&gt; value used in solver input,</span>
<span class="sd">        for example, for gr1c</span>
<span class="sd">    @return:</span>
<span class="sd">        - conjunct (includes `&amp;&amp;` operator) if:</span>

<span class="sd">            - `action_type` in `actions_dict`, and</span>
<span class="sd">            - `action_value` is not</span>
<span class="sd">              the empty string (modeling &quot;no constrain&quot;)</span>

<span class="sd">          includes next operator (`X`) if `nxt = True`.</span>
<span class="sd">        - empty string otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">action_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">actions_dict</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">actions_dict</span><span class="p">[</span><span class="n">action_type</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">action</span> <span class="o">=</span> <span class="n">ids</span><span class="p">[</span><span class="n">action</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">nxt</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39; X</span><span class="si">{</span><span class="n">_pstr</span><span class="p">(</span><span class="n">action</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">_pstr</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_conj_actions</span><span class="p">(</span>
        <span class="n">actions_dict</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">solver_expr</span><span class="p">:</span>
            <span class="nb">dict</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nxt</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Conjunction of multiple action types.</span>

<span class="sd">    Includes solver expression substitution.</span>
<span class="sd">    See also `_conj_action`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;conjunction of actions: </span><span class="si">{</span><span class="n">actions_dict</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s1">&#39;mapping to solver equivalents: &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">solver_expr</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">actions_dict</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;actions_dict empty, returning empty string</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="n">solver_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">actions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">solver_expr</span><span class="p">[</span>
                <span class="n">type_name</span><span class="p">][</span>
                <span class="n">action_value</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">type_name</span><span class="p">,</span> <span class="n">action_value</span> <span class="ow">in</span>
                <span class="n">actions_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">actions</span> <span class="o">=</span> <span class="n">actions_dict</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;after substitution: </span><span class="si">{</span><span class="n">actions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">conjuncted_actions</span> <span class="o">=</span> <span class="n">_conj</span><span class="p">(</span><span class="n">actions</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s1">&#39;conjuncted actions: &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">conjuncted_actions</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nxt</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39; X</span><span class="si">{</span><span class="n">_pstr</span><span class="p">(</span><span class="n">conjuncted_actions</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">_pstr</span><span class="p">(</span><span class="n">conjuncted_actions</span><span class="p">)</span>

<span class="c1"># duplicate states are impossible,</span>
<span class="c1"># because each networkx vertex is unique</span>
<span class="c1"># non-contiguous integers for states work too,</span>
<span class="c1"># though a less efficient representation.</span>


<span class="k">def</span> <span class="nf">iter2var</span><span class="p">(</span>
        <span class="n">states</span><span class="p">:</span>
            <span class="n">_abc</span><span class="o">.</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">variables</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">:</span>
            <span class="nb">str</span><span class="p">,</span>
        <span class="n">bool_states</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">must</span><span class="p">:</span>
            <span class="n">_ty</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span>
                <span class="s1">&#39;mutex&#39;</span><span class="p">,</span>
                <span class="s1">&#39;xor&#39;</span><span class="p">,</span>
                <span class="kc">None</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="nb">dict</span><span class="p">,</span>
            <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represent finite domain in GR(1).</span>

<span class="sd">    An integer or string variable can be used,</span>
<span class="sd">    or multiple Boolean variables.</span>

<span class="sd">    If the possible values are:</span>

<span class="sd">      - mutually exclusive (use_mutex == True)</span>
<span class="sd">      - bool actions have not been requested (bool_actions == False)</span>

<span class="sd">    then an integer or string variable represents the variable in GR(1).</span>

<span class="sd">    If all values are integers, then an integer is used.</span>
<span class="sd">    If all values are strings, then a string variable is used.</span>
<span class="sd">    Otherwise an exception is raised, unless Booleans have been requested.</span>

<span class="sd">    If the values are not mutually exclusive,</span>
<span class="sd">    then only Boolean variables can represent them.</span>

<span class="sd">    Suppose N possible values are defined.</span>
<span class="sd">    The int variable is allowed to take N+1 values.</span>
<span class="sd">    The additional value corresponds to all, e.g., actions, being False.</span>

<span class="sd">    If FTS values are integers,</span>
<span class="sd">    then the additional action is an int value.</span>

<span class="sd">    If FTS values are strings (e.g., &#39;park&#39;, &#39;wait&#39;),</span>
<span class="sd">    then the additional action is &#39;none&#39;.</span>
<span class="sd">    They are treated by `spec` as an arbitrary finite domain.</span>

<span class="sd">    An option `min_one` is internally available,</span>
<span class="sd">    in order to allow only N values of the variable.</span>
<span class="sd">    This requires that the variable takes at least one value each time.</span>

<span class="sd">    Combined with a mutex constraint, it yields an n-ary xor constraint.</span>

<span class="sd">    @param states:</span>
<span class="sd">        values of domain.</span>
<span class="sd">    @param variables:</span>
<span class="sd">        to be augmented with</span>
<span class="sd">        integer or</span>
<span class="sd">        string variable or</span>
<span class="sd">        Boolean variables.</span>
<span class="sd">    @param statevar:</span>
<span class="sd">        name to use for integer or string valued variable.</span>
<span class="sd">    @param bool_states:</span>
<span class="sd">        if True, then use bool variables.</span>
<span class="sd">        Otherwise use integer or string valued variable.</span>
<span class="sd">    @return:</span>
<span class="sd">        `tuple` of:</span>
<span class="sd">        - mapping from values to GR(1) actions.</span>
<span class="sd">          If Booleans are used, then GR(1) are the same.</span>
<span class="sd">          Otherwise, they map to e.g. &#39;act = &quot;wait&quot;&#39; or &#39;act = 3&#39;</span>
<span class="sd">        - constraints to be added to `trans` and/or `init` in GR(1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;empty container, so empty dict for solver expr&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">dict</span><span class="p">(),</span> <span class="kc">None</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;mapping domain: </span><span class="si">{</span><span class="n">states</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">to expression understood by &#39;</span>
        <span class="s1">&#39;a GR(1) solver.&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">must</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;mutex&#39;</span><span class="p">,</span> <span class="s1">&#39;xor&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">}</span>
    <span class="c1"># options for modeling actions</span>
    <span class="k">if</span> <span class="n">must</span> <span class="ow">in</span> <span class="p">{</span><span class="s1">&#39;mutex&#39;</span><span class="p">,</span> <span class="s1">&#39;xor&#39;</span><span class="p">}:</span>
        <span class="n">use_mutex</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">use_mutex</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">must</span> <span class="o">==</span> <span class="s1">&#39;xor&#39;</span><span class="p">:</span>
        <span class="n">min_one</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">min_one</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># no mutex -&gt; cannot use int variable</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_mutex</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;not using mutex: &#39;</span>
            <span class="s1">&#39;Booleans must model actions&#39;</span><span class="p">)</span>
        <span class="n">bool_states</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s1">&#39;options for modeling actions:</span><span class="se">\n\t</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;mutex: </span><span class="si">{</span><span class="n">use_mutex</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">min_one: </span><span class="si">{</span><span class="n">min_one</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">all_str</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">states</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">bool_states</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;states modeled as Boolean variables&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_str</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;If Boolean, all states must be strings.&#39;</span><span class="p">)</span>
        <span class="n">state_ids</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="n">s</span><span class="p">:</span> <span class="s1">&#39;boolean&#39;</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">})</span>
        <span class="c1"># single action ?</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mutex</span><span class="p">(</span><span class="n">state_ids</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">state_ids</span><span class="p">,</span> <span class="kc">None</span>
        <span class="c1"># handle multiple actions</span>
        <span class="k">if</span> <span class="n">use_mutex</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">min_one</span><span class="p">:</span>
            <span class="n">constraint</span> <span class="o">=</span> <span class="n">mutex</span><span class="p">(</span><span class="n">state_ids</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">use_mutex</span> <span class="ow">and</span> <span class="n">min_one</span><span class="p">:</span>
            <span class="n">constraint</span> <span class="o">=</span> <span class="n">exactly_one</span><span class="p">(</span><span class="n">state_ids</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">min_one</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;min_one requires mutex&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constraint</span> <span class="o">=</span> <span class="s1">&#39;True&#39;</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="p">[</span><span class="n">constraint</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;states not modeled as Booleans&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">statevar</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;state variable: </span><span class="si">{</span><span class="n">statevar</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; already exists in: </span><span class="si">{</span><span class="n">variables</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">all_int</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">states</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_int</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;all states are integers&#39;</span><span class="p">)</span>
            <span class="c1"># extra value modeling all False ?</span>
            <span class="k">if</span> <span class="n">min_one</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">states</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">statevar</span><span class="si">}</span><span class="s1"> = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">states</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;created solver variable: </span><span class="si">{</span><span class="n">statevar</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\t</span><span class="s1"> with domain: </span><span class="si">{</span><span class="n">domain</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">all_str</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;all states are strings&#39;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">use_mutex</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">statevar</span><span class="si">}</span><span class="s1"> = &quot;</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">min_one</span><span class="p">:</span>
                <span class="n">domain</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">statevar</span><span class="si">}</span><span class="s1">none&#39;</span><span class="p">]</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="s1">&#39;domain has been extended, because all actions</span><span class="se">\n\t</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;could be False (constraint: min_one = False).&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Integer and string states must not be mixed.&#39;</span><span class="p">)</span>
        <span class="n">state_ids</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">states</span><span class="p">}</span>
        <span class="n">variables</span><span class="p">[</span><span class="n">statevar</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">constraint</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">tabs</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;for tulip variable: </span><span class="si">{</span><span class="n">statevar</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="s1">&#39;the map from [tulip action values] ---&gt; &#39;</span>
        <span class="s1">&#39;[solver expressions] is:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tabs</span><span class="si">}{</span><span class="n">state_ids</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">constraint</span>


<span class="k">def</span> <span class="nf">_add_actions</span><span class="p">(</span>
        <span class="n">constraint</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">init</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">,</span>
        <span class="n">trans</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="n">trans</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;X (</span><span class="si">{</span><span class="n">constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">]</span>
    <span class="n">init</span> <span class="o">+=</span> <span class="n">constraint</span>


<span class="k">def</span> <span class="nf">_fts2spec</span><span class="p">(</span>
        <span class="n">fts</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">,</span>
        <span class="n">ignore_initial</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">:</span>
            <span class="nb">str</span><span class="p">,</span>
        <span class="n">actionvar</span><span class="p">:</span>
            <span class="nb">str</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">bool_states</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bool_actions</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert closed FTS to GR(1) representation.&quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;deprecated&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fts</span><span class="p">,</span> <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">)</span>
    <span class="n">aps</span> <span class="o">=</span> <span class="n">fts</span><span class="o">.</span><span class="n">aps</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">fts</span><span class="o">.</span><span class="n">states</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="n">fts</span><span class="o">.</span><span class="n">actions</span>
    <span class="n">sys_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sys_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sys_vars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ap</span><span class="p">:</span> <span class="s1">&#39;boolean&#39;</span>
        <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">aps</span><span class="p">}</span>
    <span class="n">action_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
        <span class="n">actions</span><span class="p">,</span> <span class="n">sys_vars</span><span class="p">,</span>
        <span class="n">actionvar</span><span class="p">,</span> <span class="n">bool_actions</span><span class="p">,</span>
        <span class="n">fts</span><span class="o">.</span><span class="n">actions_must</span><span class="p">)</span>
    <span class="n">_add_actions</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">sys_init</span><span class="p">,</span> <span class="n">sys_trans</span><span class="p">)</span>
    <span class="n">state_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">sys_vars</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">,</span> <span class="n">bool_states</span><span class="p">,</span>
        <span class="n">must</span><span class="o">=</span><span class="s1">&#39;xor&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys_trans</span> <span class="o">+=</span> <span class="n">constraint</span>
    <span class="n">sys_init</span> <span class="o">+=</span> <span class="n">_sys_init_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">aps</span><span class="p">,</span> <span class="n">ignore_initial</span><span class="p">)</span>
    <span class="n">sys_trans</span> <span class="o">+=</span> <span class="n">_sys_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">fts</span><span class="o">.</span><span class="n">transitions</span><span class="p">,</span>
        <span class="n">action_ids</span><span class="o">=</span><span class="n">action_ids</span><span class="p">)</span>
    <span class="n">tmp_init</span><span class="p">,</span> <span class="n">tmp_trans</span> <span class="o">=</span> <span class="n">_ap_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
    <span class="n">sys_init</span> <span class="o">+=</span> <span class="n">tmp_init</span>
    <span class="n">sys_trans</span> <span class="o">+=</span> <span class="n">tmp_trans</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">sys_vars</span><span class="p">,</span>
        <span class="n">sys_init</span><span class="p">,</span>
        <span class="n">sys_trans</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sys_to_spec</span><span class="p">(</span>
        <span class="n">ofts</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">,</span>
        <span class="n">ignore_initial</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">:</span>
            <span class="nb">str</span><span class="p">,</span>
        <span class="n">bool_states</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bool_actions</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert transition system to GR(1) fragment of LTL.</span>

<span class="sd">    The attribute `FTS.owner` defines who controls the system,</span>
<span class="sd">    as described next. It can take values `&#39;env&#39;` or `&#39;sys&#39;`.</span>

<span class="sd">    The following are represented by</span>
<span class="sd">    variables controlled by `ofts.owner`:</span>

<span class="sd">      - the current state</span>
<span class="sd">      - the atomic propositions annotating states</span>
<span class="sd">      - the system actions annotating edges</span>

<span class="sd">    The following are represented by</span>
<span class="sd">    variables controlled by the other player:</span>

<span class="sd">      - the environment actions annotating edges</span>

<span class="sd">    Multiple types of environment and system actions can be defined.</span>
<span class="sd">    Make sure that, depending on the player,</span>
<span class="sd">    `&#39;env&#39;` or `&#39;sys&#39;` are part of the action type names,</span>
<span class="sd">    so that `synth.synthesize` can recognize them.</span>

<span class="sd">    Caution</span>
<span class="sd">    =======</span>
<span class="sd">    There are aspects of `FTS` that</span>
<span class="sd">    need to be separately specified in a logic formula.</span>

<span class="sd">    An example are the initial conditions constraining the values</span>
<span class="sd">    of environment and system actions.</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>
<span class="sd">    `sys_trans_from_ts}, `env_open_fts2spec`,</span>
<span class="sd">    `create_actions`, `create_states`</span>

<span class="sd">    @param ignore_initial:</span>
<span class="sd">        Do not include initial state info from TS.</span>
<span class="sd">        Enable this to mask absence of FTS initial states.</span>
<span class="sd">        Useful when initial states are specified in another way,</span>
<span class="sd">        e.g., directly augmenting the spec part.</span>
<span class="sd">    @param state_var:</span>
<span class="sd">        name to be used for the integer or string</span>
<span class="sd">        variable that equals the current transition system state.</span>
<span class="sd">    @param bool_states:</span>
<span class="sd">        deprecated as inefficient</span>

<span class="sd">        if `True`, then use one Boolean variable</span>
<span class="sd">        to represent each state (one-hot encoding).</span>
<span class="sd">        Otherwise use a single integer variable,</span>
<span class="sd">        different values of which correspond to states of</span>
<span class="sd">        `ofts` (binary encoding).</span>
<span class="sd">    @param bool_actions:</span>
<span class="sd">        Similar to `bool_states`.</span>
<span class="sd">        For each type of system actions,</span>
<span class="sd">        and each type of environment actions:</span>

<span class="sd">          - if `True`, then for each possible value of that action type,</span>
<span class="sd">            use a different Boolean variable to represent it.</span>

<span class="sd">          - Otherwise use a single integer variable,</span>
<span class="sd">            that ranges over the possible action values.</span>
<span class="sd">    @return:</span>
<span class="sd">        logic formula in GR(1) form representing `ofts`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ofts</span><span class="p">,</span> <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;ofts must be FTS, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;got instead: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ofts</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ofts</span><span class="o">.</span><span class="n">owner</span> <span class="o">==</span> <span class="s1">&#39;sys&#39;</span>
    <span class="n">aps</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">aps</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">states</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">transitions</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">aps</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="c1"># init</span>
    <span class="n">sys_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sys_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">env_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">env_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sys_vars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ap</span><span class="p">:</span> <span class="s1">&#39;boolean&#39;</span>
        <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">aps</span><span class="p">}</span>
    <span class="n">env_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">actions</span>
    <span class="n">sys_action_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">env_action_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">action_type</span><span class="p">,</span> <span class="n">codomain</span> <span class="ow">in</span> <span class="n">actions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">aps</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action_type</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">action_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action_type</span> <span class="ow">in</span> <span class="n">aps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">action_type</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;action_type:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">action_type</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;with codomain:</span><span class="se">\n\t</span><span class="si">{</span><span class="n">codomain</span><span class="si">}</span><span class="s1">&#39;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;sys&#39;</span> <span class="ow">in</span> <span class="n">action_type</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found sys action&#39;</span><span class="p">)</span>
            <span class="n">action_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">sys_vars</span><span class="p">,</span>
                <span class="n">action_type</span><span class="p">,</span> <span class="n">bool_actions</span><span class="p">,</span>
                <span class="n">ofts</span><span class="o">.</span><span class="n">sys_actions_must</span><span class="p">)</span>
            <span class="n">_add_actions</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">sys_init</span><span class="p">,</span> <span class="n">sys_trans</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;Updating sys_action_ids with:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">action_ids</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">sys_action_ids</span><span class="p">[</span><span class="n">action_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">action_ids</span>
        <span class="k">elif</span> <span class="s1">&#39;env&#39;</span> <span class="ow">in</span> <span class="n">action_type</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Found env action&#39;</span><span class="p">)</span>
            <span class="n">action_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">env_vars</span><span class="p">,</span>
                <span class="n">action_type</span><span class="p">,</span> <span class="n">bool_actions</span><span class="p">,</span>
                <span class="n">ofts</span><span class="o">.</span><span class="n">env_actions_must</span><span class="p">)</span>
            <span class="n">_add_actions</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="n">env_init</span><span class="p">,</span> <span class="n">env_trans</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="s1">&#39;Updating env_action_ids with:</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">action_ids</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">env_action_ids</span><span class="p">[</span><span class="n">action_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">action_ids</span>
    <span class="n">state_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">sys_vars</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">,</span> <span class="n">bool_states</span><span class="p">,</span>
        <span class="n">must</span><span class="o">=</span><span class="s1">&#39;xor&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sys_trans</span> <span class="o">+=</span> <span class="n">constraint</span>
    <span class="n">sys_init</span> <span class="o">+=</span> <span class="n">_sys_init_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">aps</span><span class="p">,</span> <span class="n">ignore_initial</span><span class="p">)</span>
    <span class="n">sys_trans</span> <span class="o">+=</span> <span class="n">_sys_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
        <span class="n">sys_action_ids</span><span class="o">=</span><span class="n">sys_action_ids</span><span class="p">,</span>
        <span class="n">env_action_ids</span><span class="o">=</span><span class="n">env_action_ids</span><span class="p">)</span>
    <span class="n">tmp_init</span><span class="p">,</span> <span class="n">tmp_trans</span> <span class="o">=</span> <span class="n">_ap_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
    <span class="n">sys_init</span> <span class="o">+=</span> <span class="n">tmp_init</span>
    <span class="n">sys_trans</span> <span class="o">+=</span> <span class="n">tmp_trans</span>
    <span class="n">env_trans</span> <span class="o">+=</span> <span class="n">_env_trans_from_sys_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">env_action_ids</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">(</span>
        <span class="n">sys_vars</span><span class="o">=</span><span class="n">sys_vars</span><span class="p">,</span>
        <span class="n">env_vars</span><span class="o">=</span><span class="n">env_vars</span><span class="p">,</span>
        <span class="n">env_init</span><span class="o">=</span><span class="n">env_init</span><span class="p">,</span>
        <span class="n">sys_init</span><span class="o">=</span><span class="n">sys_init</span><span class="p">,</span>
        <span class="n">env_safety</span><span class="o">=</span><span class="n">env_trans</span><span class="p">,</span>
        <span class="n">sys_safety</span><span class="o">=</span><span class="n">sys_trans</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">env_to_spec</span><span class="p">(</span>
        <span class="n">ofts</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">,</span>
        <span class="n">ignore_initial</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">:</span>
            <span class="nb">str</span><span class="p">,</span>
        <span class="n">bool_states</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">bool_actions</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert env transition system to GR(1) representation.</span>

<span class="sd">    The following are represented by environment variables:</span>

<span class="sd">      - the current state</span>
<span class="sd">      - the atomic propositions annotating states</span>
<span class="sd">      - the environment actions annotating edges</span>

<span class="sd">    The following are represented by system variables:</span>

<span class="sd">      - the system actions annotating edges</span>

<span class="sd">    Multiple types of environment and system actions can be defined.</span>

<span class="sd">    For more details see `sys_to_spec`.</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>
<span class="sd">    `sys_open_fts2spec`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ofts</span><span class="p">,</span> <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;ofts must be FTS, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;got instead: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ofts</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ofts</span><span class="o">.</span><span class="n">owner</span> <span class="o">==</span> <span class="s1">&#39;env&#39;</span>
    <span class="n">aps</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">aps</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">states</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">transitions</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">aps</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="c1"># init</span>
    <span class="n">sys_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sys_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">env_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">env_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># since APs are tied to env states,</span>
    <span class="c1"># let them be env variables</span>
    <span class="n">env_vars</span> <span class="o">=</span> <span class="p">{</span><span class="n">ap</span><span class="p">:</span> <span class="s1">&#39;boolean&#39;</span> <span class="k">for</span> <span class="n">ap</span> <span class="ow">in</span> <span class="n">aps</span><span class="p">}</span>
    <span class="n">sys_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">actions</span> <span class="o">=</span> <span class="n">ofts</span><span class="o">.</span><span class="n">actions</span>
    <span class="n">sys_action_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">env_action_ids</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">action_type</span><span class="p">,</span> <span class="n">codomain</span> <span class="ow">in</span> <span class="n">actions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">aps</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">codomain</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action_type</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">action_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">action_type</span> <span class="ow">in</span> <span class="n">aps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
                <span class="n">action_type</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;sys&#39;</span> <span class="ow">in</span> <span class="n">action_type</span><span class="p">:</span>
            <span class="n">action_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">sys_vars</span><span class="p">,</span>
                <span class="n">action_type</span><span class="p">,</span> <span class="n">bool_actions</span><span class="p">,</span>
                <span class="n">ofts</span><span class="o">.</span><span class="n">sys_actions_must</span><span class="p">)</span>
            <span class="n">_add_actions</span><span class="p">(</span>
                <span class="n">constraint</span><span class="p">,</span>
                <span class="n">sys_init</span><span class="p">,</span>
                <span class="n">sys_trans</span><span class="p">)</span>
            <span class="n">sys_action_ids</span><span class="p">[</span><span class="n">action_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">action_ids</span>
        <span class="k">elif</span> <span class="s1">&#39;env&#39;</span> <span class="ow">in</span> <span class="n">action_type</span><span class="p">:</span>
            <span class="n">action_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
                <span class="n">codomain</span><span class="p">,</span> <span class="n">env_vars</span><span class="p">,</span>
                <span class="n">action_type</span><span class="p">,</span> <span class="n">bool_actions</span><span class="p">,</span>
                <span class="n">ofts</span><span class="o">.</span><span class="n">env_actions_must</span><span class="p">)</span>
            <span class="n">_add_actions</span><span class="p">(</span>
                <span class="n">constraint</span><span class="p">,</span>
                <span class="n">env_init</span><span class="p">,</span>
                <span class="n">env_trans</span><span class="p">)</span>
            <span class="n">env_action_ids</span><span class="p">[</span><span class="n">action_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">action_ids</span>
    <span class="c1"># some duplication here,</span>
    <span class="c1"># because we don&#39;t know</span>
    <span class="c1"># whether the user will provide</span>
    <span class="c1"># a system TS as well</span>
    <span class="c1"># and whether that TS will contain</span>
    <span class="c1"># all the system actions</span>
    <span class="c1"># defined in the environment TS</span>
    <span class="n">state_ids</span><span class="p">,</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">env_vars</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">,</span> <span class="n">bool_states</span><span class="p">,</span>
        <span class="n">must</span><span class="o">=</span><span class="s1">&#39;xor&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">constraint</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">env_trans</span> <span class="o">+=</span> <span class="n">constraint</span>
    <span class="n">env_init</span> <span class="o">+=</span> <span class="n">_sys_init_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">aps</span><span class="p">,</span> <span class="n">ignore_initial</span><span class="p">)</span>
    <span class="n">env_trans</span> <span class="o">+=</span> <span class="n">_env_trans_from_env_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
        <span class="n">env_action_ids</span><span class="o">=</span><span class="n">env_action_ids</span><span class="p">,</span>
        <span class="n">sys_action_ids</span><span class="o">=</span><span class="n">sys_action_ids</span><span class="p">)</span>
    <span class="n">tmp_init</span><span class="p">,</span> <span class="n">tmp_trans</span> <span class="o">=</span> <span class="n">_ap_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span> <span class="n">state_ids</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
    <span class="n">env_init</span> <span class="o">+=</span> <span class="n">tmp_init</span>
    <span class="n">env_trans</span> <span class="o">+=</span> <span class="n">tmp_trans</span>
    <span class="k">return</span> <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">(</span>
        <span class="n">sys_vars</span><span class="o">=</span><span class="n">sys_vars</span><span class="p">,</span>
        <span class="n">env_vars</span><span class="o">=</span><span class="n">env_vars</span><span class="p">,</span>
        <span class="n">env_init</span><span class="o">=</span><span class="n">env_init</span><span class="p">,</span>
        <span class="n">sys_init</span><span class="o">=</span><span class="n">sys_init</span><span class="p">,</span>
        <span class="n">env_safety</span><span class="o">=</span><span class="n">env_trans</span><span class="p">,</span>
        <span class="n">sys_safety</span><span class="o">=</span><span class="n">sys_trans</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sys_init_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">state_ids</span><span class="p">,</span>
        <span class="n">aps</span><span class="p">,</span>
        <span class="n">ignore_initial</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Formulas</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initial state, including enforcement of exactly one.&quot;&quot;&quot;</span>
    <span class="n">init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># skip ?</span>
    <span class="k">if</span> <span class="n">ignore_initial</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">init</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">states</span><span class="o">.</span><span class="n">initial</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;FTS has no initial states.</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Enforcing this renders False the GR(1):</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39; - guarantee if this is a system TS,</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;   so the spec becomes trivially False.</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39; - assumption if this is an environment TS,</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;   so the spec becomes trivially True.&#39;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;False&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">init</span>
    <span class="n">init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
        <span class="n">_disj</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span>
            <span class="n">state_ids</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span>
            <span class="n">states</span><span class="o">.</span><span class="n">initial</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">init</span>


<span class="k">def</span> <span class="nf">_sys_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">state_ids</span><span class="p">,</span>
        <span class="n">trans</span><span class="p">,</span>
        <span class="n">action_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sys_action_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">env_action_ids</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Formulas</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert transition relation to GR(1) sys_safety.</span>

<span class="sd">    The transition relation may be closed or open,</span>
<span class="sd">    i.e., depend only on system, or also on environment actions.</span>

<span class="sd">    No mutexes enforced by this function among:</span>

<span class="sd">        - sys states</span>
<span class="sd">        - env actions</span>

<span class="sd">    An edge attribute &#39;previous&#39; can be optionally set to</span>
<span class="sd">    an iterable of edge attribute keys.</span>
<span class="sd">    The actions with those action_types those keys</span>
<span class="sd">    will not be prepended by the next operator.</span>

<span class="sd">    This enables defining both current and next actions, e.g.,</span>

<span class="sd">    some_action &amp;&amp; X(some_other_action)</span>

<span class="sd">    About label type checking: in principle everything should work the</span>
<span class="sd">    same if the base class LabeledDiGraph was replaced by MultiDiGraph,</span>
<span class="sd">    so that users can play around with their own bare graphs,</span>
<span class="sd">    when they don&#39;t need the label typing overhead.</span>

<span class="sd">    @param trans:</span>
<span class="sd">        `Transitions` as from the transitions</span>
<span class="sd">        attribute of `FTS`.</span>
<span class="sd">    @param action_ids:</span>
<span class="sd">        same as `sys-action_ids`</span>
<span class="sd">        Caution: to be removed in a future release</span>
<span class="sd">    @param sys_action_ids:</span>
<span class="sd">        dict of dicts</span>
<span class="sd">        outer dict keyed by action_type</span>
<span class="sd">        each inner dict keyed by action_value</span>
<span class="sd">        each inner dict value is the</span>
<span class="sd">        solver expression for that action value</span>

<span class="sd">        for example an action type with an</span>
<span class="sd">        arbitrary finite discrete codomain can be modeled either:</span>

<span class="sd">          - as Boolean variables, so each possible action value</span>
<span class="sd">            becomes a different Boolean variable with the same</span>
<span class="sd">            name, thus `sys_action_ids[action_type]` will be</span>
<span class="sd">            the identity map on `action_values` for that `action_type`.</span>

<span class="sd">          - as integer variables, so each possible action value</span>
<span class="sd">            becomes a different expression in the solver (e.g. gr1c)</span>
<span class="sd">            input format. Then `sys_action_ids[action_type]` maps</span>
<span class="sd">            `action_value` -&gt; solver expression of the form:</span>

<span class="sd">            `action_type = i`</span>

<span class="sd">            where `i` corresponds to that particular  `action_type`.</span>
<span class="sd">    @param env_action_ids:</span>
<span class="sd">        same as `sys-action_ids`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;modeling sys transitions in logic&#39;</span><span class="p">)</span>
    <span class="n">sys_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># Transitions</span>
    <span class="k">for</span> <span class="n">from_state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">from_state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">from_state</span><span class="p">]</span>
        <span class="n">precond</span> <span class="o">=</span> <span class="n">_pstr</span><span class="p">(</span><span class="n">from_state_id</span><span class="p">)</span>
        <span class="n">cur_trans</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">find</span><span class="p">([</span><span class="n">from_state</span><span class="p">])</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;from state: </span><span class="si">{</span><span class="n">from_state</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="s1">&#39;, the available transitions are:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">cur_trans</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># no successor states ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cur_trans</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;state: </span><span class="si">{</span><span class="n">from_state</span><span class="si">}</span><span class="s1"> is deadend !&#39;</span><span class="p">)</span>
            <span class="n">sys_trans</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">precond</span><span class="si">}</span><span class="s1"> -&gt; X(False)&#39;</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">cur_str</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">cur_trans</span><span class="p">:</span>
            <span class="n">to_state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">to_state</span><span class="p">]</span>
            <span class="n">postcond</span> <span class="o">=</span> <span class="p">[</span>
                <span class="sa">f</span><span class="s1">&#39;X</span><span class="si">{</span><span class="n">_pstr</span><span class="p">(</span><span class="n">to_state_id</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;label = </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;previous&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
                <span class="n">previous</span> <span class="o">=</span> <span class="n">label</span><span class="p">[</span><span class="s1">&#39;previous&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">previous</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;previous = </span><span class="si">{</span><span class="n">previous</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">env_actions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s1">&#39;env&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
            <span class="n">prev_env_act</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">env_actions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">previous</span><span class="p">}</span>
            <span class="n">next_env_act</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">env_actions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">previous</span><span class="p">}</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_conj_actions</span><span class="p">(</span><span class="n">prev_env_act</span><span class="p">,</span> <span class="n">env_action_ids</span><span class="p">,</span>
                                       <span class="n">nxt</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_conj_actions</span><span class="p">(</span><span class="n">next_env_act</span><span class="p">,</span> <span class="n">env_action_ids</span><span class="p">,</span>
                                       <span class="n">nxt</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="n">sys_actions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s1">&#39;sys&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
            <span class="n">prev_sys_act</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">sys_actions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">previous</span><span class="p">}</span>
            <span class="n">next_sys_act</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">sys_actions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">previous</span><span class="p">}</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">_conj_actions</span><span class="p">(</span>
                    <span class="n">prev_sys_act</span><span class="p">,</span> <span class="n">sys_action_ids</span><span class="p">,</span>
                    <span class="n">nxt</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">_conj_actions</span><span class="p">(</span>
                    <span class="n">next_sys_act</span><span class="p">,</span> <span class="n">sys_action_ids</span><span class="p">,</span>
                    <span class="n">nxt</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="c1"># if system FTS given</span>
            <span class="c1"># in case &#39;actions in label,</span>
            <span class="c1"># then action_ids is a dict,</span>
            <span class="c1"># not a dict of dicts,</span>
            <span class="c1"># because certainly this came</span>
            <span class="c1"># from an FTS, not an OpenFTS</span>
            <span class="k">if</span> <span class="s1">&#39;actions&#39;</span> <span class="ow">in</span> <span class="n">previous</span><span class="p">:</span>
                <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">_conj_action</span><span class="p">(</span>
                        <span class="n">label</span><span class="p">,</span> <span class="s1">&#39;actions&#39;</span><span class="p">,</span>
                        <span class="n">ids</span><span class="o">=</span><span class="n">action_ids</span><span class="p">,</span>
                        <span class="n">nxt</span><span class="o">=</span><span class="kc">False</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                    <span class="n">_conj_action</span><span class="p">(</span>
                        <span class="n">label</span><span class="p">,</span> <span class="s1">&#39;actions&#39;</span><span class="p">,</span>
                        <span class="n">ids</span><span class="o">=</span><span class="n">action_ids</span><span class="p">,</span>
                        <span class="n">nxt</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="n">cur_str</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_conj</span><span class="p">(</span><span class="n">postcond</span><span class="p">)]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;guard to state: </span><span class="si">{</span><span class="n">to_state</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;, with state_id: </span><span class="si">{</span><span class="n">to_state_id</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;, has post-conditions: </span><span class="si">{</span><span class="n">postcond</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">sys_trans</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">precond</span><span class="si">}</span><span class="s1"> -&gt; (</span><span class="si">{</span><span class="n">_disj</span><span class="p">(</span><span class="n">cur_str</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sys_trans</span>


<span class="k">def</span> <span class="nf">_env_trans_from_sys_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">state_ids</span><span class="p">,</span>
        <span class="n">trans</span><span class="p">,</span>
        <span class="n">env_action_ids</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Formulas</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert environment actions to GR(1) env_safety.</span>

<span class="sd">    This constrains the actions available next to the environment</span>
<span class="sd">    based on the system FTS.</span>

<span class="sd">    Purpose is to prevent env from blocking sys by purely</span>
<span class="sd">    picking a combination of actions for which sys has no outgoing</span>
<span class="sd">    transition from that state.</span>

<span class="sd">    Might become optional in the future,</span>
<span class="sd">    depending on the desired way of defining env behavior.</span>

<span class="sd">    @param env_action_ids:</span>
<span class="sd">        dict of dicts,</span>
<span class="sd">        see `sys_trans_from_ts`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">env_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># this probably useless for multiple action types</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">env_action_ids</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">env_trans</span>
    <span class="k">for</span> <span class="n">from_state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">from_state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">from_state</span><span class="p">]</span>
        <span class="n">precond</span> <span class="o">=</span> <span class="n">_pstr</span><span class="p">(</span><span class="n">from_state_id</span><span class="p">)</span>
        <span class="n">cur_trans</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">find</span><span class="p">([</span><span class="n">from_state</span><span class="p">])</span>
        <span class="c1"># no successor states ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cur_trans</span><span class="p">:</span>
            <span class="c1"># nothing modeled for env,</span>
            <span class="c1"># since sys has X(False) anyway</span>
            <span class="c1"># for action_type, codomain_map in env_action_ids.items():</span>
            <span class="c1"># env_trans += [f&#39;{precond} -&gt; X({s})&#39;]</span>
            <span class="k">continue</span>
        <span class="c1"># collect possible next env actions</span>
        <span class="n">next_env_action_combs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">cur_trans</span><span class="p">:</span>
            <span class="n">env_actions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s1">&#39;env&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">env_actions</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;env_actions: </span><span class="si">{</span><span class="n">env_actions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;env_action_ids: </span><span class="si">{</span><span class="n">env_action_ids</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">env_action_comb</span> <span class="o">=</span> <span class="n">_conj_actions</span><span class="p">(</span>
                <span class="n">env_actions</span><span class="p">,</span> <span class="n">env_action_ids</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;env_action_comb: </span><span class="si">{</span><span class="n">env_action_comb</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">next_env_action_combs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">env_action_comb</span><span class="p">)</span>
        <span class="n">next_env_actions</span> <span class="o">=</span> <span class="n">_disj</span><span class="p">(</span><span class="n">next_env_action_combs</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;next_env_actions: </span><span class="si">{</span><span class="n">next_env_actions</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># no next env actions ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">next_env_actions</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">env_trans</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">precond</span><span class="si">}</span><span class="s1"> -&gt; X(</span><span class="si">{</span><span class="n">next_env_actions</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">env_trans</span>


<span class="k">def</span> <span class="nf">_env_trans_from_env_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">state_ids</span><span class="p">,</span>
        <span class="n">trans</span><span class="p">,</span>
        <span class="n">action_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">env_action_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sys_action_ids</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Formulas</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert environment TS transitions to GR(1) representation.</span>

<span class="sd">    This contributes to the \rho_e(X, Y, X&#39;) part of the spec,</span>
<span class="sd">    i.e., constrains the next environment state variables&#39; valuation</span>
<span class="sd">    depending on the previous environment state variables valuation</span>
<span class="sd">    and the previous system action (system output).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">env_trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">from_state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">from_state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">from_state</span><span class="p">]</span>
        <span class="n">precond</span> <span class="o">=</span> <span class="n">_pstr</span><span class="p">(</span><span class="n">from_state_id</span><span class="p">)</span>
        <span class="n">cur_trans</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">find</span><span class="p">([</span><span class="n">from_state</span><span class="p">])</span>
        <span class="c1"># no successor states ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cur_trans</span><span class="p">:</span>
            <span class="n">env_trans</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">precond</span><span class="si">}</span><span class="s1"> -&gt; X(False)&#39;</span><span class="p">]</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;Environment dead-end found.</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;If sys can force env to dead-end,</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;then GR(1) assumption becomes False,</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;and spec trivially True.&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">cur_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">found_free</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># any environment transition</span>
        <span class="c1"># not conditioned on the previous system output ?</span>
        <span class="k">for</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">cur_trans</span><span class="p">:</span>
            <span class="n">to_state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">to_state</span><span class="p">]</span>
            <span class="n">postcond</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;X</span><span class="si">{</span><span class="n">_pstr</span><span class="p">(</span><span class="n">to_state_id</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
            <span class="n">env_actions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s1">&#39;env&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">_conj_actions</span><span class="p">(</span>
                    <span class="n">env_actions</span><span class="p">,</span>
                    <span class="n">env_action_ids</span><span class="p">,</span>
                    <span class="n">nxt</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
            <span class="c1"># remember: this is</span>
            <span class="c1"># an environment FTS,</span>
            <span class="c1"># so no next for sys</span>
            <span class="n">sys_actions</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="s1">&#39;sys&#39;</span> <span class="ow">in</span> <span class="n">k</span><span class="p">}</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">_conj_actions</span><span class="p">(</span>
                    <span class="n">sys_actions</span><span class="p">,</span>
                    <span class="n">sys_action_ids</span><span class="p">)]</span>
            <span class="n">postcond</span> <span class="o">+=</span> <span class="p">[</span>
                <span class="n">_conj_action</span><span class="p">(</span>
                    <span class="n">label</span><span class="p">,</span> <span class="s1">&#39;actions&#39;</span><span class="p">,</span>
                    <span class="n">nxt</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">ids</span><span class="o">=</span><span class="n">action_ids</span><span class="p">)]</span>
            <span class="c1"># todo: test this clause</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sys_actions</span><span class="p">:</span>
                <span class="n">found_free</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">cur_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">_conj</span><span class="p">(</span><span class="n">postcond</span><span class="p">)]</span>
        <span class="c1"># can sys block env by</span>
        <span class="c1"># setting all previous sys outputs to False ?</span>
        <span class="c1"># then env assumption becomes False,</span>
        <span class="c1"># so the spec trivially True: avoid this</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found_free</span> <span class="ow">and</span> <span class="n">sys_action_ids</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s1">&#39;no free env outgoing transition found</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;instead will take disjunction with negated sys actions&#39;</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">action_type</span><span class="p">,</span> <span class="n">codomain</span> <span class="ow">in</span> <span class="n">sys_action_ids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">conj</span> <span class="o">=</span> <span class="n">_conj_neg</span><span class="p">(</span><span class="n">codomain</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
                <span class="n">cur_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">conj</span><span class="p">]</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;for action_type: </span><span class="si">{</span><span class="n">action_type</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;with codomain: </span><span class="si">{</span><span class="n">codomain</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;the negated conjunction is: </span><span class="si">{</span><span class="n">conj</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">env_trans</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">_pstr</span><span class="p">(</span><span class="n">precond</span><span class="p">)</span><span class="si">}</span><span class="s1"> -&gt; &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">_disj</span><span class="p">(</span><span class="n">cur_list</span><span class="p">)</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">env_trans</span>


<span class="k">def</span> <span class="nf">_ap_trans_from_ts</span><span class="p">(</span>
        <span class="n">states</span><span class="p">,</span>
        <span class="n">state_ids</span><span class="p">,</span>
        <span class="n">aps</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="n">Formulas</span><span class="p">,</span>
            <span class="n">Formulas</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Require atomic propositions to follow states according to label.&quot;&quot;&quot;</span>
    <span class="n">init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># no AP labels ?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">aps</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
    <span class="c1"># initial labeling</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">ap_str</span> <span class="o">=</span> <span class="n">_sprint_aps</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ap_str</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">init</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;!(</span><span class="si">{</span><span class="n">_pstr</span><span class="p">(</span><span class="n">state_id</span><span class="p">)</span><span class="si">}</span><span class="s1">) || (</span><span class="si">{</span><span class="n">ap_str</span><span class="si">}</span><span class="s1">)&#39;</span><span class="p">]</span>
    <span class="c1"># transitions of labels</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">state_id</span> <span class="o">=</span> <span class="n">state_ids</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">_sprint_aps</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tmp</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">trans</span> <span class="o">+=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s1">&#39;X((</span><span class="si">{</span><span class="n">state_id</span><span class="si">}</span><span class="s1">) -&gt; (</span><span class="si">{</span><span class="n">tmp</span><span class="si">}</span><span class="s1">))&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sprint_aps</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">aps</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">if</span> <span class="s1">&#39;ap&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
        <span class="n">tmp0</span> <span class="o">=</span> <span class="n">_conj_intersection</span><span class="p">(</span>
            <span class="n">aps</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="s1">&#39;ap&#39;</span><span class="p">],</span>
            <span class="n">parenth</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp0</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;ap&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">_conj_neg_diff</span><span class="p">(</span>
            <span class="n">aps</span><span class="p">,</span> <span class="n">label</span><span class="p">[</span><span class="s1">&#39;ap&#39;</span><span class="p">],</span>
            <span class="n">parenth</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp1</span> <span class="o">=</span> <span class="n">_conj_neg</span><span class="p">(</span>
            <span class="n">aps</span><span class="p">,</span>
            <span class="n">parenth</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tmp0</span> <span class="ow">and</span> <span class="n">tmp1</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tmp0</span><span class="si">}</span><span class="s1"> &amp;&amp; </span><span class="si">{</span><span class="n">tmp1</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tmp0</span><span class="si">}{</span><span class="n">tmp1</span><span class="si">}</span><span class="s1">&#39;</span>
    <span class="k">return</span> <span class="n">tmp</span>


<span class="k">def</span> <span class="nf">build_dependent_var_table</span><span class="p">(</span>
        <span class="n">fts</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">FTS</span><span class="p">,</span>
        <span class="n">statevar</span><span class="p">:</span>
            <span class="nb">str</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return substitution rules for dependent variables.</span>

<span class="sd">    The dependent variables in a transition system are the</span>
<span class="sd">    atomic propositions that are used to label states.</span>

<span class="sd">    They are &quot;dependent&quot; because their values are completely</span>
<span class="sd">    determined by knowledge of the current state in the</span>
<span class="sd">    transition system.</span>

<span class="sd">    The returned substitutions can be used</span>

<span class="sd">    @param statevar:</span>
<span class="sd">        name of variable used for the current state</span>
<span class="sd">        For example if it is &#39;loc&#39;, then the states</span>
<span class="sd">        `&#39;s0&#39;, &#39;s1&#39;` are mapped to:</span>

<span class="sd">        ```python</span>
<span class="sd">        {&#39;s0&#39;: &#39;(loc = &quot;s0&quot;)&#39;,</span>
<span class="sd">         &#39;s1&#39;: &#39;(loc = &quot;s1&quot;)&#39;}</span>
<span class="sd">        ```</span>
<span class="sd">    @return:</span>
<span class="sd">        `{&#39;p&#39;: &#39;((loc = &quot;s1&quot;) | (loc = &quot;s2&quot;) | ...)&#39;, ...}`</span>
<span class="sd">        where:</span>

<span class="sd">          - `&#39;p&#39;` is a proposition in</span>
<span class="sd">            `fts.atomic_propositions`</span>
<span class="sd">          - the states &quot;s1&quot;, &quot;s2&quot; are labeled with `&#39;p&#39;`</span>
<span class="sd">          - `loc` is the string variable used for</span>
<span class="sd">            the state of `fts`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state_ids</span><span class="p">,</span> <span class="n">__</span> <span class="o">=</span> <span class="n">iter2var</span><span class="p">(</span>
        <span class="n">fts</span><span class="o">.</span><span class="n">states</span><span class="p">,</span>
        <span class="n">variables</span><span class="o">=</span><span class="nb">dict</span><span class="p">(),</span>
        <span class="n">statevar</span><span class="o">=</span><span class="n">statevar</span><span class="p">,</span>
        <span class="n">bool_states</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">must</span><span class="o">=</span><span class="s1">&#39;xor&#39;</span><span class="p">)</span>
    <span class="n">ap2states</span> <span class="o">=</span> <span class="n">map_ap_to_states</span><span class="p">(</span><span class="n">fts</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">_disj</span><span class="p">(</span><span class="n">state_ids</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ap2states</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">map_ap_to_states</span><span class="p">(</span>
        <span class="n">fts</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">FTS</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For each proposition find the states labeled with it.</span>

<span class="sd">    @return:</span>
<span class="sd">        `{&#39;p&#39;: s, ...}` where</span>
<span class="sd">        `&#39;p&#39;` a proposition and</span>
<span class="sd">        `s` a set of states in `fts`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">fts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">fts</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">fts</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]:</span>
            <span class="n">table</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">table</span>


<span class="k">def</span> <span class="nf">synthesize_many</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">ts</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span>
                <span class="nb">str</span><span class="p">,</span>
                <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">]</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ignore_init</span><span class="p">:</span>
            <span class="nb">set</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">solver</span><span class="p">:</span>
            <span class="n">Solver</span><span class="o">=</span><span class="s1">&#39;omega&#39;</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">maybe_mealy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Synthesize from logic specs and multiple transition systems.</span>

<span class="sd">    The transition systems are composed synchronously, i.e.,</span>
<span class="sd">    they all have to take a transition at each time step.</span>
<span class="sd">    The synchronous composition is obtained by taking the</span>
<span class="sd">    conjunction of the formulas describing each transition system.</span>

<span class="sd">    The states of each transition system can be either:</span>

<span class="sd">      - all integers, or</span>
<span class="sd">      - all strings</span>

<span class="sd">    In either case the transition system state will be</span>
<span class="sd">    represented in logic with a single variable,</span>
<span class="sd">    that ranges over a finite set of</span>
<span class="sd">    integers or strings, respectively.</span>

<span class="sd">    The keys of `ts` are used to name each state variable.</span>
<span class="sd">    So the logic formula for `ts[&#39;name&#39;]` will be `&#39;name&#39;`.</span>

<span class="sd">    Who controls this state variable is determined from</span>
<span class="sd">    the attribute `FTS.owner` that can take the values:</span>

<span class="sd">      - `&#39;env&#39;`</span>
<span class="sd">      - `&#39;sys&#39;`</span>

<span class="sd">    For example:</span>

<span class="sd">    ```python</span>
<span class="sd">    ts.states.add_from(range(4))</span>
<span class="sd">    ts[&#39;door&#39;].owner = &#39;env&#39;</span>
<span class="sd">    ```</span>

<span class="sd">    will result in a logic formula with</span>
<span class="sd">    an integer variable `&#39;door&#39;`</span>
<span class="sd">    controlled by the environment and</span>
<span class="sd">    taking values over `{0, 1, 2, 3}`.</span>

<span class="sd">    The example:</span>

<span class="sd">    ```python</span>
<span class="sd">    ts.states.add_from([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span>
<span class="sd">    ts[&#39;door&#39;].owner = &#39;sys&#39;</span>
<span class="sd">    ```</span>

<span class="sd">    will instead result in a string variable `&#39;door&#39;`</span>
<span class="sd">    controlled by the system and taking</span>
<span class="sd">    values over `{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}`.</span>

<span class="sd">    @param ignore_init:</span>
<span class="sd">        `set` of keys from `ts`</span>
<span class="sd">    @param solver:</span>
<span class="sd">        See function `synthesize` for</span>
<span class="sd">        available options.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="n">ts</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">transys</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">ignore</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">ignore_init</span>
        <span class="n">statevar</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">match</span> <span class="n">t</span><span class="o">.</span><span class="n">owner</span><span class="p">:</span>
            <span class="k">case</span> <span class="s1">&#39;sys&#39;</span><span class="p">:</span>
                <span class="n">sys_spec</span> <span class="o">=</span> <span class="n">sys_to_spec</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ignore</span><span class="p">,</span> <span class="n">statevar</span><span class="p">)</span>
                <span class="n">_copy_options_from_ts</span><span class="p">(</span><span class="n">sys_spec</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
                <span class="n">specs</span> <span class="o">|=</span> <span class="n">sys_spec</span>
            <span class="k">case</span> <span class="s1">&#39;env&#39;</span><span class="p">:</span>
                <span class="n">env_spec</span> <span class="o">=</span> <span class="n">env_to_spec</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ignore</span><span class="p">,</span> <span class="n">statevar</span><span class="p">)</span>
                <span class="n">_copy_options_from_ts</span><span class="p">(</span><span class="n">env_spec</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
                <span class="n">specs</span> <span class="o">|=</span> <span class="n">env_spec</span>
    <span class="k">return</span> <span class="n">_synthesize</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span>
        <span class="n">rm_deadends</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>


<div class="viewcode-block" id="synthesize">
<a class="viewcode-back" href="../tutorial.html#synth.synthesize">[docs]</a>
<span class="k">def</span> <span class="nf">synthesize</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">env</span><span class="p">:</span>
            <span class="n">maybe_fts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sys</span><span class="p">:</span>
            <span class="n">maybe_fts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ignore_env_init</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_sys_init</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">rm_deadends</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">solver</span><span class="p">:</span>
            <span class="n">Solver</span><span class="o">=</span><span class="s1">&#39;omega&#39;</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">maybe_mealy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Call synthesis tool `solver` on the specification.</span>

<span class="sd">    There are three attributes of `specs` that define what</span>
<span class="sd">    kind of controller you are looking for:</span>

<span class="sd">    1. `moore`:</span>
<span class="sd">       What information the controller knows</span>
<span class="sd">       when deciding the next</span>
<span class="sd">       values of controlled variables:</span>
<span class="sd">        - Moore: can read current state,</span>
<span class="sd">          but not next environment variable values, or</span>
<span class="sd">        - Mealy: can read current state and</span>
<span class="sd">          next environment variable values.</span>

<span class="sd">    2. `qinit`:</span>
<span class="sd">        Quantification of initial variable values:</span>
<span class="sd">        Whether all states that satisfy</span>
<span class="sd">        a predicate should be winning,</span>
<span class="sd">        or the initial values of</span>
<span class="sd">        some (or all) the variables is</span>
<span class="sd">        subject to the synthesizer&#39;s choice.</span>

<span class="sd">    3. `plus_one`:</span>
<span class="sd">        The form of assume-guarantee specification,</span>
<span class="sd">        i.e., how the system guarantees relate to</span>
<span class="sd">        assumptions about the environment.</span>

<span class="sd">    For more details about these attributes, see `GRSpec`.</span>

<span class="sd">    The states of the transition system can be either:</span>

<span class="sd">      - all integers, or</span>
<span class="sd">      - all strings</span>

<span class="sd">    For more details of how</span>
<span class="sd">    the transition system is represented in</span>
<span class="sd">    logic look at `synthesize_many`.</span>

<span class="sd">    Beware!</span>
<span class="sd">    =======</span>
<span class="sd">    This function provides a generic interface to a variety</span>
<span class="sd">    of routines.  Being under active development, the types of</span>
<span class="sd">    arguments supported and types of objects returned may change</span>
<span class="sd">    without notice.</span>

<span class="sd">    @param env:</span>
<span class="sd">        A transition system describing the environment:</span>

<span class="sd">            - states controlled by environment</span>
<span class="sd">            - input: sys_actions</span>
<span class="sd">            - output: env_actions</span>
<span class="sd">            - initial states constrain the environment</span>

<span class="sd">        This constrains the transitions available to</span>
<span class="sd">        the environment, given the outputs from the system.</span>
<span class="sd">    @param sys:</span>
<span class="sd">        A transition system describing the system:</span>

<span class="sd">            - states controlled by the system</span>
<span class="sd">            - input: env_actions</span>
<span class="sd">            - output: sys_actions</span>
<span class="sd">            - initial states constrain the system</span>
<span class="sd">    @param ignore_env_init:</span>
<span class="sd">        Ignore any initial state information</span>
<span class="sd">        contained in env.</span>
<span class="sd">    @param ignore_sys_init:</span>
<span class="sd">        Ignore any initial state information</span>
<span class="sd">        contained in sys.</span>
<span class="sd">    @param rm_deadends:</span>
<span class="sd">        return a strategy that contains no terminal states.</span>
<span class="sd">    @param solver:</span>
<span class="sd">        Magic string that declares what tool to invoke,</span>
<span class="sd">        what method to use, etc.  Currently recognized forms:</span>

<span class="sd">        For GR(1) synthesis:</span>

<span class="sd">          - `&quot;gr1c&quot;`:</span>
<span class="sd">            use gr1c via `interfaces.gr1c`.</span>
<span class="sd">            written in C using CUDD, symbolic</span>

<span class="sd">          - `&quot;gr1py&quot;`:</span>
<span class="sd">            use gr1py via `interfaces.gr1py`.</span>
<span class="sd">            Python, enumerative</span>

<span class="sd">          - `&quot;omega&quot;`:</span>
<span class="sd">            use omega via `interfaces.omega`.</span>
<span class="sd">            Python using `dd` or Cython using CUDD, symbolic</span>

<span class="sd">          - `&quot;slugs&quot;`:</span>
<span class="sd">            use slugs via `interfaces.slugs`.</span>
<span class="sd">            C++ using CUDD, symbolic</span>
<span class="sd">    @return:</span>
<span class="sd">        If spec is realizable,</span>
<span class="sd">        then return a Mealy machine implementing the strategy.</span>
<span class="sd">        Otherwise return None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">specs</span> <span class="o">=</span> <span class="n">_spec_plus_sys</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span>
        <span class="n">ignore_env_init</span><span class="p">,</span>
        <span class="n">ignore_sys_init</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_synthesize</span><span class="p">(</span><span class="n">specs</span><span class="p">,</span> <span class="n">solver</span><span class="p">,</span> <span class="n">rm_deadends</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_synthesize</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">solver</span><span class="p">:</span>
            <span class="n">Solver</span><span class="p">,</span>
        <span class="n">rm_deadends</span><span class="p">:</span>
            <span class="nb">bool</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">maybe_mealy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `MealyMachine` that implements `specs`.&quot;&quot;&quot;</span>
    <span class="k">match</span> <span class="n">solver</span><span class="p">:</span>
        <span class="k">case</span> <span class="s1">&#39;gr1c&#39;</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">gr1c</span><span class="o">.</span><span class="n">synthesize</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span> <span class="s1">&#39;slugs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slugs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Import of slugs interface failed. &#39;</span>
                    <span class="s1">&#39;Please verify installation of &quot;slugs&quot;.&#39;</span><span class="p">)</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">slugs</span><span class="o">.</span><span class="n">synthesize</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span> <span class="s1">&#39;gr1py&#39;</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">gr1py</span><span class="o">.</span><span class="n">synthesize</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span> <span class="s1">&#39;omega&#39;</span><span class="p">:</span>
            <span class="n">strategy</span> <span class="o">=</span> <span class="n">omega_int</span><span class="o">.</span><span class="n">synthesize_enumerated_streett</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;gr1c&#39;</span><span class="p">,</span> <span class="s1">&#39;gr1py&#39;</span><span class="p">,</span> <span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;slugs&#39;</span><span class="p">}</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Unknown solver: &quot;</span><span class="si">{</span><span class="n">solver</span><span class="si">}</span><span class="s1">&quot;. &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;Available options are: </span><span class="si">{</span><span class="n">options</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_trim_strategy</span><span class="p">(</span>
        <span class="n">strategy</span><span class="p">,</span> <span class="n">specs</span><span class="p">,</span>
        <span class="n">rm_deadends</span><span class="o">=</span><span class="n">rm_deadends</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_trim_strategy</span><span class="p">(</span>
        <span class="n">strategy</span><span class="p">:</span>
            <span class="n">maybe_mealy</span><span class="p">,</span>
        <span class="n">specs</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">rm_deadends</span><span class="p">:</span>
            <span class="nb">bool</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">maybe_mealy</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return `MealyMachine` without deadends, or `None`.</span>

<span class="sd">    If `strategy is None`, then return `None`.</span>

<span class="sd">    @param rm_deadends:</span>
<span class="sd">        if `True`, then remove deadends</span>
<span class="sd">        from the Mealy machine</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># While the return values of</span>
    <span class="c1"># the solver interfaces vary,</span>
    <span class="c1"># we expect here that strategy is</span>
    <span class="c1"># either None to indicate unrealizable or</span>
    <span class="c1"># a networkx.DiGraph ready to be</span>
    <span class="c1"># passed to strategy2mealy().</span>
    <span class="k">if</span> <span class="n">strategy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">ctrl</span> <span class="o">=</span> <span class="n">strategy2mealy</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="s1">&#39;Mealy machine has: &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;n = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ctrl</span><span class="o">.</span><span class="n">states</span><span class="p">)</span><span class="si">}</span><span class="s1"> states.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rm_deadends</span><span class="p">:</span>
        <span class="n">ctrl</span><span class="o">.</span><span class="n">remove_deadends</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ctrl</span>


<span class="k">def</span> <span class="nf">is_realizable</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">env</span><span class="p">:</span>
            <span class="n">maybe_fts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">sys</span><span class="p">:</span>
            <span class="n">maybe_fts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ignore_env_init</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">ignore_sys_init</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">solver</span><span class="p">:</span>
            <span class="n">Solver</span><span class="o">=</span><span class="s1">&#39;omega&#39;</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check realizability.</span>

<span class="sd">    For details see `synthesize`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">specs</span> <span class="o">=</span> <span class="n">_spec_plus_sys</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span>
        <span class="n">ignore_env_init</span><span class="p">,</span> <span class="n">ignore_sys_init</span><span class="p">)</span>
    <span class="k">match</span> <span class="n">solver</span><span class="p">:</span>
        <span class="k">case</span> <span class="s1">&#39;gr1c&#39;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">gr1c</span><span class="o">.</span><span class="n">check_realizable</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span> <span class="s1">&#39;slugs&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">slugs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Import of slugs interface failed. &#39;</span>
                    <span class="s1">&#39;Please verify installation of &quot;slugs&quot;.&#39;</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">slugs</span><span class="o">.</span><span class="n">check_realizable</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span> <span class="s1">&#39;gr1py&#39;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">gr1py</span><span class="o">.</span><span class="n">check_realizable</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span> <span class="s1">&#39;omega&#39;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">omega_int</span><span class="o">.</span><span class="n">is_realizable</span><span class="p">(</span><span class="n">specs</span><span class="p">)</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Undefined synthesis solver: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">solver</span><span class="w"> </span><span class="si">= }</span><span class="s1">&#39;</span>
                <span class="s1">&#39;Available options are &quot;gr1c&quot;, &#39;</span>
                <span class="s1">&#39;&quot;slugs&quot;, and &quot;gr1py&quot;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;is realizable&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;is not realizable&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">_spec_plus_sys</span><span class="p">(</span>
        <span class="n">specs</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">env</span><span class="p">:</span>
            <span class="n">maybe_fts</span><span class="p">,</span>
        <span class="n">sys</span><span class="p">:</span>
            <span class="n">maybe_fts</span><span class="p">,</span>
        <span class="n">ignore_env_init</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">ignore_sys_init</span><span class="p">:</span>
            <span class="nb">bool</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">sys</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="p">,</span> <span class="s1">&#39;state_varname&#39;</span><span class="p">):</span>
            <span class="n">statevar</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">state_varname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;sys.state_varname undefined. &#39;</span>
                <span class="s1">&#39;Will use the default &#39;</span>
                <span class="s1">&#39;variable name: &quot;loc&quot;.&#39;</span><span class="p">)</span>
            <span class="n">statevar</span> <span class="o">=</span> <span class="s1">&#39;loc&#39;</span>
        <span class="n">sys_formula</span> <span class="o">=</span> <span class="n">sys_to_spec</span><span class="p">(</span>
            <span class="n">sys</span><span class="p">,</span> <span class="n">ignore_sys_init</span><span class="p">,</span>
            <span class="n">statevar</span><span class="o">=</span><span class="n">statevar</span><span class="p">)</span>
        <span class="n">_copy_options_from_ts</span><span class="p">(</span>
            <span class="n">sys_formula</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specs</span><span class="o">.</span><span class="n">qinit</span> <span class="o">==</span> <span class="sa">r</span><span class="s1">&#39;\A \A&#39;</span><span class="p">:</span>
            <span class="n">sys_formula</span><span class="o">.</span><span class="n">env_init</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">sys_formula</span><span class="o">.</span><span class="n">sys_init</span><span class="p">)</span>
            <span class="n">sys_formula</span><span class="o">.</span><span class="n">sys_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span> <span class="o">|</span> <span class="n">sys_formula</span>
        <span class="n">pp_formula</span> <span class="o">=</span> <span class="n">sys_formula</span><span class="o">.</span><span class="n">pretty</span><span class="p">()</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;sys TS:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pp_formula</span><span class="si">}{</span><span class="n">_hl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">env</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s1">&#39;state_varname&#39;</span><span class="p">):</span>
            <span class="n">statevar</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">state_varname</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;env.state_varname undefined. &#39;</span>
                <span class="s1">&#39;Will use the default &#39;</span>
                <span class="s1">&#39;variable name: &quot;eloc&quot;.&#39;</span><span class="p">)</span>
            <span class="n">statevar</span> <span class="o">=</span> <span class="s1">&#39;eloc&#39;</span>
        <span class="n">env_formula</span> <span class="o">=</span> <span class="n">env_to_spec</span><span class="p">(</span>
            <span class="n">env</span><span class="p">,</span> <span class="n">ignore_env_init</span><span class="p">,</span>
            <span class="n">statevar</span><span class="o">=</span><span class="n">statevar</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specs</span><span class="o">.</span><span class="n">qinit</span> <span class="o">==</span> <span class="sa">r</span><span class="s1">&#39;\A \A&#39;</span><span class="p">:</span>
            <span class="n">env_formula</span><span class="o">.</span><span class="n">env_init</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">env_formula</span><span class="o">.</span><span class="n">sys_init</span><span class="p">)</span>
            <span class="n">env_formula</span><span class="o">.</span><span class="n">sys_init</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">_copy_options_from_ts</span><span class="p">(</span><span class="n">env_formula</span><span class="p">,</span> <span class="n">env</span><span class="p">,</span> <span class="n">specs</span><span class="p">)</span>
        <span class="n">specs</span> <span class="o">=</span> <span class="n">specs</span> <span class="o">|</span> <span class="n">env_formula</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="s1">&#39;env TS:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">env_formula</span><span class="o">.</span><span class="n">pretty</span><span class="p">()</span><span class="si">}{</span><span class="n">_hl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s1">&#39;Overall Spec:</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">specs</span><span class="o">.</span><span class="n">pretty</span><span class="p">()</span><span class="si">}{</span><span class="n">_hl</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">specs</span>


<span class="k">def</span> <span class="nf">_copy_options_from_ts</span><span class="p">(</span>
        <span class="n">ts_spec</span><span class="p">,</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">specs</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Copy `moore, qinit, plus_one` from `ts`, if set.</span>

<span class="sd">    Otherwise copy the values of those attributes from `specs`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ts</span><span class="p">,</span> <span class="s1">&#39;moore&#39;</span><span class="p">):</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">ts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">specs</span>
    <span class="n">ts_spec</span><span class="o">.</span><span class="n">moore</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">moore</span>
    <span class="n">ts_spec</span><span class="o">.</span><span class="n">plus_one</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">plus_one</span>
    <span class="n">ts_spec</span><span class="o">.</span><span class="n">qinit</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">qinit</span>


<span class="k">def</span> <span class="nf">strategy2mealy</span><span class="p">(</span>
        <span class="n">A</span><span class="p">:</span>
            <span class="n">_nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span>
        <span class="n">spec</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert strategy to Mealy transducer.</span>

<span class="sd">    Note that the strategy is a deterministic game graph,</span>
<span class="sd">    but the input `A` is given as the contraction of</span>
<span class="sd">    this game graph.</span>

<span class="sd">    @param A:</span>
<span class="sd">        strategy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="s1">&#39;graph `A` has no nodes, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">A</span><span class="w"> </span><span class="si">= }</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s1">&#39;converting strategy (compact) &#39;</span>
        <span class="s1">&#39;to Mealy machine&#39;</span><span class="p">)</span>
    <span class="n">env_vars</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">env_vars</span>
    <span class="n">sys_vars</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">sys_vars</span>
    <span class="n">mach</span> <span class="o">=</span> <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span><span class="p">()</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="n">transys</span><span class="o">.</span><span class="n">machines</span><span class="o">.</span><span class="n">create_machine_ports</span><span class="p">(</span><span class="n">env_vars</span><span class="p">)</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">add_inputs</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">outputs</span> <span class="o">=</span> <span class="n">transys</span><span class="o">.</span><span class="n">machines</span><span class="o">.</span><span class="n">create_machine_ports</span><span class="p">(</span><span class="n">sys_vars</span><span class="p">)</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">add_outputs</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="n">str_vars</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
            <span class="n">env_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)}</span>
    <span class="n">str_vars</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
            <span class="n">sys_vars</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">list</span><span class="p">)})</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">all_vars</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">env_vars</span><span class="p">)</span>
    <span class="n">all_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">sys_vars</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
    <span class="n">strategy_vars</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;state&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_vars</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">strategy_vars</span><span class="p">)</span>
    <span class="c1"># transitions labeled with I/O</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;state&#39;</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">}</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">_int2str</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">str_vars</span><span class="p">)</span>
            <span class="n">mach</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
                <span class="n">attr_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">d</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;node: </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">, state: </span><span class="si">{</span><span class="n">d</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># special initial state, for first reaction</span>
    <span class="n">initial_state</span> <span class="o">=</span> <span class="s1">&#39;Sinit&#39;</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">initial</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
    <span class="c1"># fix an ordering for keys</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">all_vars</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;initial_nodes&#39;</span><span class="p">):</span>
        <span class="n">_init_edges_using_initial_nodes</span><span class="p">(</span>
            <span class="n">A</span><span class="p">,</span> <span class="n">mach</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span>
            <span class="n">all_vars</span><span class="p">,</span> <span class="n">str_vars</span><span class="p">,</span>
            <span class="n">initial_state</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_init_edges_using_compile_init</span><span class="p">(</span>
            <span class="n">spec</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">mach</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span>
            <span class="n">all_vars</span><span class="p">,</span> <span class="n">str_vars</span><span class="p">,</span>
            <span class="n">initial_state</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mach</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">mach</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="s1">&#39;Sinit&#39;</span><span class="p">):</span>
        <span class="n">newlines</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span>
            <span class="n">A</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span>
            <span class="s1">&#39;The machine obtained from the strategy &#39;</span>
            <span class="s1">&#39;does not have any initial states !</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;The strategy is:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;vertices:</span><span class="si">{</span><span class="n">nodes</span><span class="si">}{</span><span class="n">newlines</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;edges:</span><span class="se">\n</span><span class="si">{</span><span class="n">A</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="si">}{</span><span class="n">newlines</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;and the machine:</span><span class="se">\n</span><span class="si">{</span><span class="n">mach</span><span class="si">}{</span><span class="n">newlines</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="s1">&#39;and the specification is:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">spec</span><span class="o">.</span><span class="n">pretty</span><span class="p">()</span><span class="si">}{</span><span class="n">newlines</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mach</span>


<span class="k">def</span> <span class="nf">_init_edges_using_initial_nodes</span><span class="p">(</span>
        <span class="n">A</span><span class="p">:</span>
            <span class="n">_nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span>
        <span class="n">mach</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">,</span>
        <span class="n">all_vars</span><span class="p">,</span>
        <span class="n">str_vars</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">initial_state</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">assert</span> <span class="n">A</span><span class="o">.</span><span class="n">initial_nodes</span>
    <span class="n">init_valuations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">initial_nodes</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;state&#39;</span><span class="p">]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>
        <span class="c1"># already an initial valuation ?</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">init_valuations</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">init_valuations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">}</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">_int2str</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">str_vars</span><span class="p">)</span>
        <span class="n">mach</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
            <span class="n">initial_state</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span>
            <span class="n">attr_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">d</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_init_edges_using_compile_init</span><span class="p">(</span>
        <span class="n">spec</span><span class="p">:</span>
            <span class="n">_spec</span><span class="o">.</span><span class="n">GRSpec</span><span class="p">,</span>
        <span class="n">A</span><span class="p">:</span>
            <span class="n">_nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">,</span>
        <span class="n">mach</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span><span class="p">,</span>
        <span class="n">keys</span><span class="p">,</span>
        <span class="n">all_vars</span><span class="p">,</span>
        <span class="n">str_vars</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">initial_state</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">init_valuations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># to store tuples of</span>
    <span class="c1"># dict values for fast search</span>
    <span class="n">isinit</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="n">compile_init</span><span class="p">(</span><span class="n">no_str</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Mealy reaction to initial env input</span>
    <span class="n">init_valuations</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">A</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">var_values</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;state&#39;</span><span class="p">]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var_values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>
        <span class="c1"># already an initial valuation ?</span>
        <span class="k">if</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">init_valuations</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># add edge: Sinit -&gt; u ?</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">eval</span><span class="p">(</span><span class="n">isinit</span><span class="p">,</span> <span class="n">tmp</span><span class="p">):</span>
            <span class="n">var_values</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                    <span class="n">var_values</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">all_vars</span><span class="p">}</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">_int2str</span><span class="p">(</span><span class="n">var_values</span><span class="p">,</span> <span class="n">str_vars</span><span class="p">)</span>
            <span class="n">mach</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="n">initial_state</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span>
                <span class="n">attr_dict</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="o">**</span><span class="n">label</span><span class="p">)</span>
            <span class="c1"># remember variable values to avoid</span>
            <span class="c1"># spurious non-determinism wrt</span>
            <span class="c1"># the machine&#39;s memory</span>
            <span class="c1">#</span>
            <span class="c1"># in other words,</span>
            <span class="c1"># &quot;state&quot; omits the strategy&#39;s memory</span>
            <span class="c1"># hidden (existentially quantified)</span>
            <span class="c1"># so multiple nodes can be</span>
            <span class="c1"># labeled with the same state</span>
            <span class="c1">#</span>
            <span class="c1"># non-uniqueness here would be</span>
            <span class="c1"># equivalent to multiple choices for</span>
            <span class="c1"># initializing the hidden memory.</span>
            <span class="n">init_valuations</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;found initial state: </span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;machine vertex: </span><span class="si">{</span><span class="n">u</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;has var values: </span><span class="si">{</span><span class="n">var_values</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_int2str</span><span class="p">(</span>
        <span class="n">label</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">str_vars</span><span class="p">:</span>
            <span class="nb">dict</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Replace integers with string values for string variables.</span>

<span class="sd">    @param label:</span>
<span class="sd">        mapping from variable names, to integer (as strings)</span>
<span class="sd">    @param str_vars:</span>
<span class="sd">        mapping that defines those variables that</span>
<span class="sd">        should be converted from integer to string variables.</span>
<span class="sd">        Each variable is mapped to a list of strings that</span>
<span class="sd">        comprise its range. This list defines how integer values</span>
<span class="sd">        correspond to string literals for that variable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">label</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="n">label</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
        <span class="n">k</span><span class="p">:</span>
            <span class="n">str_vars</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
            <span class="n">label</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">str_vars</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">label</span>


<span class="k">def</span> <span class="nf">mask_outputs</span><span class="p">(</span>
        <span class="n">machine</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Erase outputs from each edge where they are zero.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">machine</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">pop</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">k</span> <span class="ow">in</span> <span class="n">machine</span><span class="o">.</span><span class="n">outputs</span> <span class="ow">and</span>
                <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pop</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">determinize_machine_init</span><span class="p">(</span>
        <span class="n">mach</span><span class="p">:</span>
            <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span><span class="p">,</span>
        <span class="n">init_out_values</span><span class="p">:</span>
            <span class="nb">dict</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">transys</span><span class="o">.</span><span class="n">MealyMachine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a determinized copy of `mach` with given initial outputs.</span>

<span class="sd">    The transducers produced by synthesis can have multiple</span>
<span class="sd">    initial output valuations as possible reactions to a</span>
<span class="sd">    given input valuation.</span>

<span class="sd">    Possible reasons for this are:</span>

<span class="sd">      1. the system does not have full control over its initial state.</span>
<span class="sd">        For example the option &quot;ALL_INIT&quot; of `gr1c`.</span>

<span class="sd">      2. the strategy returned by the solver has multiple</span>
<span class="sd">        vertices that satisfy the initial conditions.</span>

<span class="sd">    Case 1</span>
<span class="sd">    ======</span>
<span class="sd">    Requires an initial condition to be specified for</span>
<span class="sd">    each run of the transducer, because the transducer does</span>
<span class="sd">    not have full freedom to pick the initial output values.</span>

<span class="sd">    Note that solver options like &quot;ALL_INIT&quot;</span>
<span class="sd">    assume that the system has no control initially.</span>
<span class="sd">    Any output valuation that satisfies the initial</span>
<span class="sd">    conditions can occur.</span>

<span class="sd">    However, this may be too restrictive.</span>
<span class="sd">    The system may have control over the initial values of</span>
<span class="sd">    some outputs, but not others.</span>

<span class="sd">    For the outputs it can initially control,</span>
<span class="sd">    the non-determinism resulting from synthesis is redundancy</span>
<span class="sd">    and can be removed arbitrarily, as in Case 2.</span>

<span class="sd">    Case 2</span>
<span class="sd">    ======</span>
<span class="sd">    The function `strategy2mealy` returns a transducer that</span>
<span class="sd">    for each initial input valuation,</span>
<span class="sd">    for each initial output valuation,</span>
<span class="sd">    reacts with a unique transition.</span>

<span class="sd">    But this can yield multile reactions to a single input,</span>
<span class="sd">    even for solver options like &quot;ALL_ENV_EXIST_SYS_INIT&quot; for `gr1c`.</span>
<span class="sd">    The reason is that there can be multiple strategy vertices</span>
<span class="sd">    that satisfy the initial conditions, but the solver</span>
<span class="sd">    included them not because they are needed as initial reactions,</span>
<span class="sd">    but to be visited later by the strategy.</span>

<span class="sd">    These redundant initial reactions can be removed,</span>
<span class="sd">    and because the system has full control over their values,</span>
<span class="sd">    they can be removed in an arbitrary manner,</span>
<span class="sd">    keeping only a single reaction, for each input valuation.</span>

<span class="sd">    Algorithm</span>
<span class="sd">    =========</span>
<span class="sd">    Returns a deterministic transducer.</span>
<span class="sd">    This means that at each transducer vertex,</span>
<span class="sd">    for each input valuation,</span>
<span class="sd">    there is only a single reaction (output valuation) available.</span>

<span class="sd">    The non-determinism is resolved for the initial reaction</span>
<span class="sd">    by ensuring the outputs given in `init_out_values`</span>
<span class="sd">    take those values.</span>
<span class="sd">    The remaining outputs are determinized arbitrarily.</span>

<span class="sd">    See also</span>
<span class="sd">    ========</span>
<span class="sd">    `synthesize`, `strategy2mealy`</span>

<span class="sd">    @param mach:</span>
<span class="sd">        possibly non-deterministic transducer,</span>
<span class="sd">        as produced, for example, by `synthesize`.</span>
<span class="sd">    @param init_out_values:</span>
<span class="sd">        mapping from output ports that</span>
<span class="sd">        the system cannot control initially,</span>
<span class="sd">        to the initial values they take in</span>
<span class="sd">        this instance of the game.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mach</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mach</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">init_out_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">init_out_values</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;determinize given outputs (uncontrolled)&#39;&#39;&#39;</span>
    <span class="c1"># restrict attention to</span>
    <span class="c1"># given output ports only</span>
    <span class="n">given_ports</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span>
        <span class="n">init_out_values</span><span class="o">.</span><span class="fm">__contains__</span><span class="p">,</span>
        <span class="n">mach</span><span class="o">.</span><span class="n">outputs</span><span class="p">))</span>
    <span class="n">rm_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">mach</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span>
        <span class="p">[</span><span class="s1">&#39;Sinit&#39;</span><span class="p">],</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">given_ports</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">!=</span> <span class="n">init_out_values</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">rm_edges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">))</span>
                <span class="k">break</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">rm_edges</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="c1"># determinize arbitrarily any</span>
    <span class="c1"># remnant non-determinism</span>
    <span class="c1">#</span>
    <span class="c1"># input valuations already seen</span>
    <span class="c1"># tuples of values used for</span>
    <span class="c1"># efficiency (have __hash__)</span>
    <span class="n">possible_inputs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="c1"># fix a key order</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mach</span><span class="o">.</span><span class="n">inputs</span><span class="p">)</span>
    <span class="n">rm_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">mach</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span>
        <span class="p">[</span><span class="s1">&#39;Sinit&#39;</span><span class="p">],</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">in_values</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">)</span>
        <span class="c1"># newly encountered input valuation ?</span>
        <span class="k">if</span> <span class="n">in_values</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_inputs</span><span class="p">:</span>
            <span class="n">possible_inputs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">in_values</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">rm_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
    <span class="n">mach</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">rm_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mach</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">TuLiP 1.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">synth</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2010-2017, California Institute of Technology.
      Last updated on 17 April 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.1.
    </div>
  </body>
</html>