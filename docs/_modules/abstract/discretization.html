<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>abstract.discretization &#8212; TuLiP 1.4.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css?v=ff85e404" />
    <link rel="stylesheet" type="text/css" href="../../_static/patch.css?v=0ad0caba" />
    
    <script src="../../_static/documentation_options.js?v=350a9c04"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    
    <script src="../../_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TuLiP 1.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">abstract.discretization</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for abstract.discretization</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright (c) 2011-2016 by California Institute of Technology</span>
<span class="c1"># Copyright (c) 2016 by The Regents of the University of Michigan</span>
<span class="c1"># All rights reserved.</span>
<span class="c1">#</span>
<span class="c1"># Redistribution and use in source and binary forms, with or without</span>
<span class="c1"># modification, are permitted provided that the following conditions</span>
<span class="c1"># are met:</span>
<span class="c1">#</span>
<span class="c1"># 1. Redistributions of source code must retain the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer.</span>
<span class="c1">#</span>
<span class="c1"># 2. Redistributions in binary form must reproduce the above copyright</span>
<span class="c1">#    notice, this list of conditions and the following disclaimer in the</span>
<span class="c1">#    documentation and/or other materials provided with the distribution.</span>
<span class="c1">#</span>
<span class="c1"># 3. Neither the name of the copyright holder(s) nor the names of its</span>
<span class="c1">#    contributors may be used to endorse or promote products derived</span>
<span class="c1">#    from this software without specific prior written permission.</span>
<span class="c1">#</span>
<span class="c1"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="c1"># &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="c1"># LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS</span>
<span class="c1"># FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE</span>
<span class="c1"># COPYRIGHT HOLDERS OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT,</span>
<span class="c1"># INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<span class="c1"># (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="c1"># SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span class="c1"># HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,</span>
<span class="c1"># STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING</span>
<span class="c1"># IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span>
<span class="c1"># POSSIBILITY OF SUCH DAMAGE.</span>
<span class="c1">#</span>
<span class="sd">&quot;&quot;&quot;Algorithms related to discretization of continuous dynamics.</span>

<span class="sd">See Also</span>
<span class="sd">========</span>
<span class="sd">`find_controller`</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">typing</span> <span class="k">as</span> <span class="nn">_ty</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">polytope</span> <span class="k">as</span> <span class="nn">pc</span>
<span class="kn">import</span> <span class="nn">polytope.plot</span> <span class="k">as</span> <span class="nn">_pplt</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">import</span> <span class="nn">tulip.abstract.feasible</span> <span class="k">as</span> <span class="nn">_fsb</span>
<span class="kn">import</span> <span class="nn">tulip.abstract.plot</span> <span class="k">as</span> <span class="nn">_aplt</span>
<span class="kn">import</span> <span class="nn">tulip.abstract.prop2partition</span> <span class="k">as</span> <span class="nn">_p2p</span>
<span class="kn">import</span> <span class="nn">tulip.graphics</span> <span class="k">as</span> <span class="nn">_graphics</span>
<span class="n">plt</span> <span class="o">=</span> <span class="n">_graphics</span><span class="o">.</span><span class="n">_plt</span>
<span class="n">_mpl</span> <span class="o">=</span> <span class="n">_graphics</span><span class="o">.</span><span class="n">_mpl</span>
<span class="kn">import</span> <span class="nn">tulip.hybrid</span> <span class="k">as</span> <span class="nn">_hyb</span>
<span class="kn">import</span> <span class="nn">tulip.transys</span> <span class="k">as</span> <span class="nn">trs</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;AbstractSwitched&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AbstractPwa&#39;</span><span class="p">,</span>
    <span class="s1">&#39;discretize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;discretize_switched&#39;</span><span class="p">,</span>
    <span class="s1">&#39;multiproc_discretize&#39;</span><span class="p">,</span>
    <span class="s1">&#39;multiproc_discretize_switched&#39;</span><span class="p">]</span>


<span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">Polytope</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">pc</span><span class="o">.</span><span class="n">Polytope</span> <span class="o">|</span>
    <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">)</span>
<span class="n">SystemDynamics</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">_hyb</span><span class="o">.</span><span class="n">LtiSysDyn</span> <span class="o">|</span>
    <span class="n">_hyb</span><span class="o">.</span><span class="n">PwaSysDyn</span><span class="p">)</span>
<span class="n">PPP</span> <span class="o">=</span> <span class="n">_p2p</span><span class="o">.</span><span class="n">PropPreservingPartition</span>
<span class="n">FTS</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FiniteTransitionSystem</span>


<span class="k">class</span> <span class="nc">AbstractSwitched</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstraction of `SwitchedSysDyn`.</span>

<span class="sd">    This class stores also mode-specific and</span>
<span class="sd">    common information.</span>

<span class="sd">    Attributes:</span>

<span class="sd">    - `ppp`: merged partition, if any</span>
<span class="sd">      Preserves both propositions and dynamics</span>

<span class="sd">    - `ts`: common `TS`, if any</span>

<span class="sd">    - `ppp2ts`: map from `ppp.regions` to `ts.states`</span>

<span class="sd">    - `modes`: `dict` of `{mode: AbstractPwa}`</span>

<span class="sd">    - `ppp2modes`: map from `ppp.regions` to</span>
<span class="sd">      `modes[mode].ppp.regions` of the form:</span>

<span class="sd">      ```</span>
<span class="sd">      mode: list</span>
<span class="sd">      ```</span>

<span class="sd">      where `list` has same indices as `ppp.regions` and</span>
<span class="sd">      elements in each `list` are indices of regions in</span>
<span class="sd">      each `modes[mode].ppp.regions`.</span>

<span class="sd">      - type: `dict`</span>

<span class="sd">    Each partition corresponds to some mode.</span>
<span class="sd">    (for switched systems)</span>

<span class="sd">    In each mode, a `PwaSysDyn` is active.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ppp</span><span class="p">:</span>
                <span class="n">PPP</span> <span class="o">|</span>
                <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ts</span><span class="p">:</span>
                <span class="n">FTS</span> <span class="o">|</span>
                <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ppp2ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">modes</span><span class="p">:</span>
                <span class="nb">dict</span> <span class="o">|</span>
                <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ppp2modes</span><span class="p">:</span>
                <span class="nb">dict</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">list</span><span class="p">]</span> <span class="o">|</span>
                <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">modes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">modes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span> <span class="o">=</span> <span class="n">ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ppp2ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modes</span> <span class="o">=</span> <span class="n">modes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp2modes</span> <span class="o">=</span> <span class="n">ppp2modes</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;Abstraction of switched system</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;common PPP:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;common ts:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;, with abstraction:</span><span class="se">\n</span><span class="si">{</span><span class="n">ab</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2pwa</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span>
            <span class="n">i</span><span class="p">:</span>
                <span class="nb">int</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">,</span>
                <span class="n">Polytope</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return original `Region` containing `Region` `i` in `mode`.</span>

<span class="sd">        @param mode:</span>
<span class="sd">            key of `modes`</span>
<span class="sd">        @param i:</span>
<span class="sd">            Region index in common partition `ppp.regions`</span>
<span class="sd">        @return:</span>
<span class="sd">            tuple `(j, region)` of:</span>
<span class="sd">            - index `j` of `Region` and</span>
<span class="sd">            - `Region` object</span>

<span class="sd">            in `modes[mode].ppp.regions`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">region_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2modes</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp2pwa</span><span class="p">(</span><span class="n">region_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2sys</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">mode</span><span class="p">,</span>
            <span class="n">i</span><span class="p">:</span>
                <span class="nb">int</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">,</span>
                <span class="n">_hyb</span><span class="o">.</span><span class="n">PwaSysDyn</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index of active PWA subsystem in `mode`,</span>

<span class="sd">        @param mode:</span>
<span class="sd">            key of `modes`</span>
<span class="sd">        @param i:</span>
<span class="sd">            Region index in common partition `ppp.regions`.</span>
<span class="sd">        @return:</span>
<span class="sd">            tuple `(j, subsystem)` of:</span>
<span class="sd">            - index `j` of PWA `subsystem`</span>
<span class="sd">            - `LtiSysDyn` object `subsystem`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">region_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2modes</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp2sys</span><span class="p">(</span><span class="n">region_idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">show_ts</span><span class="p">:</span>
                <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">only_adjacent</span><span class="p">:</span>
                <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="s1">&#39;_mpl.axes.Axes&#39;</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot mode partitions and merged partition, if one exists.</span>

<span class="sd">        For details read `AbstractPwa.plot`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">axs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">color_seed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># merged partition exists ?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="p">:</span>
                <span class="n">env_mode</span><span class="p">,</span> <span class="n">sys_mode</span> <span class="o">=</span> <span class="n">mode</span>
                <span class="n">edge_label</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
                    <span class="n">env_actions</span><span class="o">=</span><span class="n">env_mode</span><span class="p">,</span>
                    <span class="n">sys_actions</span><span class="o">=</span><span class="n">sys_mode</span><span class="p">)</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">_plot_abstraction</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">show_ts</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">only_adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">color_seed</span><span class="o">=</span><span class="n">color_seed</span><span class="p">)</span>
                <span class="n">_aplt</span><span class="o">.</span><span class="n">plot_ts_on_partition</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span><span class="p">,</span>
                    <span class="n">edge_label</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
                <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="c1"># plot mode partitions</span>
        <span class="k">for</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ab</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span> <span class="n">color_seed</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Abstraction for mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
        <span class="c1">#if isinstance(self.ts, dict):</span>
        <span class="c1">#    for ts in self.ts:</span>
        <span class="c1">#        ax = ts.plot()</span>
        <span class="c1">#        axs.append(ax)</span>
        <span class="k">return</span> <span class="n">axs</span>


<span class="k">class</span> <span class="nc">AbstractPwa</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Discrete abstraction of PWA dynamics, with attributes:</span>

<span class="sd">    - `ppp`: Partition into Regions.</span>
<span class="sd">      Each Region corresponds to</span>
<span class="sd">      a discrete state of the abstraction</span>

<span class="sd">      - type: `PropPreservingPartition`</span>

<span class="sd">    - `ts`: Finite transition system abstracting</span>
<span class="sd">      the continuous system.</span>
<span class="sd">      Each state corresponds to a Region in `ppp.regions`.</span>
<span class="sd">      It can be fed into discrete synthesis algorithms.</span>

<span class="sd">      - type: `FTS`</span>

<span class="sd">    - `ppp2ts`: bijection between `ppp.regions` and `ts.states`.</span>
<span class="sd">      Has common indices with `ppp.regions`.</span>
<span class="sd">      Elements are states in `ts.states`.</span>
<span class="sd">      (usually each state is a `str`)</span>

<span class="sd">      - type: `list` of states</span>

<span class="sd">    - `pwa`: system dynamics</span>

<span class="sd">      - type: `PwaSysDyn`</span>

<span class="sd">    - `pwa_ppp`: partition preserving both:</span>

<span class="sd">      - propositions and</span>
<span class="sd">      - domains of PWA subsystems</span>

<span class="sd">      Used for non-conservative planning.</span>
<span class="sd">      If just `LtiSysDyn`, then the only difference</span>
<span class="sd">      of `pwa_ppp` from `orig_ppp` is convexification.</span>

<span class="sd">      - type: `PropPreservingPartition`</span>

<span class="sd">    - `orig_ppp`: partition preserving only propositions</span>
<span class="sd">      i.e., agnostic of dynamics</span>

<span class="sd">      - type: `PropPreservingPartition`</span>

<span class="sd">    - `disc_params`: parameters used in discretization that</span>
<span class="sd">      should be passed to the controller refinement</span>
<span class="sd">      to ensure consistency</span>

<span class="sd">      - type: dict</span>

<span class="sd">    If any of the above is not given,</span>
<span class="sd">    then it is initialized to `None`.</span>

<span class="sd">    Notes</span>
<span class="sd">    =====</span>
<span class="sd">    1. There could be some redundancy in `ppp` and `ofts`,</span>
<span class="sd">       in that they are both decorated with propositions.</span>
<span class="sd">       This might be useful to keep each of</span>
<span class="sd">       them as functional units on their own</span>
<span class="sd">       (possible to change later).</span>

<span class="sd">    2. The &#39;Pwa&#39; in `AbstractPwa` includes `LtiSysDyn`</span>
<span class="sd">       as a special case.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ppp2ts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">pwa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">pwa_ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ppp2pwa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ppp2sys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">orig_ppp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">ppp2orig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">disc_params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">disc_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">disc_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span> <span class="o">=</span> <span class="n">ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">ts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ppp2ts</span>
        <span class="c1"># pwa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pwa</span> <span class="o">=</span> <span class="n">pwa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pwa_ppp</span> <span class="o">=</span> <span class="n">pwa_ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2pwa</span> <span class="o">=</span> <span class="n">ppp2pwa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span> <span class="o">=</span> <span class="n">ppp2sys</span>
        <span class="c1"># mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">orig_ppp</span> <span class="o">=</span> <span class="n">orig_ppp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2orig</span> <span class="o">=</span> <span class="n">ppp2orig</span>
        <span class="c1"># original_regions -&gt; pwa_ppp</span>
        <span class="c1"># ppp2orig -&gt; ppp2pwa_ppp</span>
        <span class="c1"># ppp2pwa -&gt; ppp2pwa_sys</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc_params</span> <span class="o">=</span> <span class="n">disc_params</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="si">}</span><span class="s1">&#39;</span> <span class="o">+</span>
            <span class="mi">30</span> <span class="o">*</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Map PPP Regions ---&gt; TS states:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Map PPP Regions ---&gt; PWA PPP Regions:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2pwa</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Map PPP Regions ---&gt; PWA Subsystems:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Map PPP Regions ---&gt; Original PPP Regions:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2other_str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ppp2orig</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Discretization Options:</span><span class="se">\n\t</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pprint</span><span class="o">.</span><span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">disc_params</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ts2ppp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="n">region_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2ts</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">region_index</span><span class="p">,</span> <span class="n">region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2trans</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">region_index</span><span class="p">:</span>
                <span class="nb">int</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
                <span class="n">Polytope</span><span class="p">,</span>
                <span class="n">_hyb</span><span class="o">.</span><span class="n">LtiSysDyn</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the transition set constraint and active subsystem,</span>

<span class="sd">        for non-conservative planning.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reg_idx</span><span class="p">,</span> <span class="n">pwa_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2pwa</span><span class="p">(</span><span class="n">region_index</span><span class="p">)</span>
        <span class="n">sys_idx</span><span class="p">,</span> <span class="n">sys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2sys</span><span class="p">(</span><span class="n">region_index</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pwa_region</span><span class="p">,</span> <span class="n">sys</span>

    <span class="k">def</span> <span class="nf">ppp2pwa</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">region_index</span><span class="p">:</span>
                <span class="nb">int</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">,</span>
                <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dynamics and predicate-preserving region</span>

<span class="sd">        and its index for PWA subsystem active in given region.</span>

<span class="sd">        The returned region is the `trans_set` used for</span>
<span class="sd">        non-conservative planning.</span>

<span class="sd">        @param region_index:</span>
<span class="sd">            index in `ppp.regions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2pwa</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="n">pwa_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwa_ppp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">pwa_region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2sys</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">region_index</span><span class="p">:</span>
                <span class="nb">int</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">,</span>
                <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index and PWA subsystem active in indexed region.</span>

<span class="sd">        Semantics: `j`-th sub-system is active in `i`-th Region,</span>
<span class="sd">        where `j = ppp2pwa[i]`</span>

<span class="sd">        @param region_index:</span>
<span class="sd">            index in `ppp.regions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># LtiSysDyn ?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwa</span><span class="p">)</span>
        <span class="n">subsystem_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2sys</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="n">subsystem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pwa</span><span class="o">.</span><span class="n">list_subsys</span><span class="p">[</span><span class="n">subsystem_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">subsystem_idx</span><span class="p">,</span> <span class="n">subsystem</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ppp2orig</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">region_index</span><span class="p">:</span>
                <span class="nb">int</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
                <span class="nb">int</span><span class="p">,</span>
                <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return index and region of original partition.</span>

<span class="sd">        The original partition is without any dynamics,</span>
<span class="sd">        not even the PWA domains, only the polytopic predicates.</span>

<span class="sd">        @param region_index:</span>
<span class="sd">            index in `ppp.regions`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ppp2orig</span><span class="p">[</span><span class="n">region_index</span><span class="p">]</span>
        <span class="n">orig_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orig_ppp</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">orig_region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ppp2other_str</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">ppp2other</span><span class="p">:</span>
                <span class="nb">list</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ppp2other</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">other</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ppp2other</span><span class="p">):</span>
            <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">other</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_debug_str_</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ppp</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="s1">&#39;(PWA + Prop)-Preserving Partition&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pwa_ppp</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="s1">&#39;Original Prop-Preserving Partition&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orig_ppp</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">show_ts</span><span class="p">:</span>
                <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">only_adjacent</span><span class="p">:</span>
                <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">color_seed</span><span class="p">:</span>
                <span class="nb">int</span> <span class="o">|</span>
                <span class="kc">None</span><span class="o">=</span><span class="kc">None</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;_mpl.axes.Axes&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Plot partition and optionally feasible transitions.</span>

<span class="sd">        @param show_ts:</span>
<span class="sd">            plot feasible transitions on partition</span>
<span class="sd">        @param only_adjacent:</span>
<span class="sd">            plot feasible transitions only</span>
<span class="sd">            between adjacent regions. This reduces clutter,</span>
<span class="sd">            but if `horizon &gt; 1` and not all horizon used,</span>
<span class="sd">            then some transitions could be hidden.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">_plot_abstraction</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">,</span> <span class="n">color_seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span>

    <span class="k">def</span> <span class="nf">verify_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;verifying transitions...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">from_state</span><span class="p">,</span> <span class="n">to_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">transitions</span><span class="p">():</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">from_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts2ppp</span><span class="p">(</span><span class="n">from_state</span><span class="p">)</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">to_region</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ts2ppp</span><span class="p">(</span><span class="n">to_state</span><span class="p">)</span>
            <span class="n">trans_set</span><span class="p">,</span> <span class="n">sys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppp2trans</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;close_loop&#39;</span><span class="p">,</span> <span class="s1">&#39;use_all_horizon&#39;</span><span class="p">}</span>
            <span class="n">disc_params</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">v</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc_params</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">params</span><span class="p">}</span>
            <span class="n">s0</span> <span class="o">=</span> <span class="n">_fsb</span><span class="o">.</span><span class="n">solve_feasible</span><span class="p">(</span>
                <span class="n">from_region</span><span class="p">,</span> <span class="n">to_region</span><span class="p">,</span> <span class="n">sys</span><span class="p">,</span>
                <span class="n">trans_set</span><span class="o">=</span><span class="n">trans_set</span><span class="p">,</span>
                <span class="o">**</span><span class="n">disc_params</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> ---&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">from_region</span> <span class="o">&lt;=</span> <span class="n">s0</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;incorrect transition: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">from_region</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">s0</span><span class="p">)</span>
                <span class="n">ratio</span> <span class="o">=</span> <span class="n">isect</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span><span class="n">from_region</span><span class="o">.</span><span class="n">volume</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;intersection volume: </span><span class="si">{</span><span class="n">ratio</span><span class="si">}</span><span class="s1"> %&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;correct transition: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_plot_abstraction</span><span class="p">(</span>
        <span class="n">ab</span><span class="p">:</span>
            <span class="n">AbstractPwa</span><span class="p">,</span>
        <span class="n">show_ts</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">only_adjacent</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">color_seed</span><span class="p">:</span>
            <span class="nb">int</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ty</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span>
            <span class="s1">&#39;_mpl.axes.Axes&#39;</span><span class="p">,</span>
            <span class="kc">None</span><span class="p">]:</span>
    <span class="k">if</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ab</span><span class="o">.</span><span class="n">ts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Either ppp or ts is None.&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">show_ts</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">ts</span>
        <span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp2ts</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ppp2ts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">ppp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
        <span class="n">ts</span><span class="p">,</span>
        <span class="n">ppp2ts</span><span class="p">,</span>
        <span class="n">only_adjacent</span><span class="o">=</span><span class="n">only_adjacent</span><span class="p">,</span>
        <span class="n">color_seed</span><span class="o">=</span><span class="n">color_seed</span><span class="p">)</span>
    <span class="c1"># ax = self.ts.plot()</span>
    <span class="k">return</span> <span class="n">ax</span>


<div class="viewcode-block" id="discretize">
<a class="viewcode-back" href="../../tutorial.html#abstract.discretize">[docs]</a>
<span class="k">def</span> <span class="nf">discretize</span><span class="p">(</span>
        <span class="n">part</span><span class="p">:</span>
            <span class="n">PPP</span><span class="p">,</span>
        <span class="n">ssys</span><span class="p">:</span>
            <span class="n">SystemDynamics</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">conservative</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_num_poly</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">use_all_horizon</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">remove_trans</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">abs_tol</span><span class="p">:</span>
            <span class="nb">float</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
        <span class="n">plotit</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_img</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cont_props</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="n">pc</span><span class="o">.</span><span class="n">Polytope</span><span class="p">]</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_every</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">simu_type</span><span class="p">:</span>
            <span class="n">_ty</span><span class="o">.</span><span class="n">Literal</span><span class="p">[</span>
                <span class="s1">&#39;bi&#39;</span><span class="p">,</span>
                <span class="s1">&#39;dual&#39;</span><span class="p">]</span>
            <span class="o">=</span><span class="s1">&#39;bi&#39;</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractPwa</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Refine the partition via bisimulation or dual-simulation.</span>

<span class="sd">    Refines the partition via either:</span>
<span class="sd">    - bisimulation, or</span>
<span class="sd">    - dual-simulation</span>

<span class="sd">    algorithms, and establish transitions</span>
<span class="sd">    based on reachability analysis.</span>


<span class="sd">    Reference</span>
<span class="sd">    =========</span>
<span class="sd">    [NOTM12](</span>
<span class="sd">        https://tulip-control.sourceforge.io/doc/bibliography.html#notm12)</span>


<span class="sd">    Relevant</span>
<span class="sd">    ========</span>
<span class="sd">    `prop2partition.pwa_partition`,</span>
<span class="sd">    `prop2partition.part2convex`</span>


<span class="sd">    @param N:</span>
<span class="sd">        horizon length</span>
<span class="sd">    @param min_cell_volume:</span>
<span class="sd">        the minimum volume of</span>
<span class="sd">        cells in the resulting partition.</span>
<span class="sd">    @param closed_loop:</span>
<span class="sd">        boolean indicating whether</span>
<span class="sd">        the `closed loop` algorithm should be used.</span>
<span class="sd">        (default is `True`)</span>
<span class="sd">    @param conservative:</span>
<span class="sd">        - `True`: force sequence in reachability analysis</span>
<span class="sd">          to stay inside starting cell</span>
<span class="sd">        - `False`: safety is ensured by keeping the</span>
<span class="sd">          sequence inside a convexified version of</span>
<span class="sd">          the original proposition-preserving cell.</span>
<span class="sd">    @param max_num_poly:</span>
<span class="sd">        maximum number of</span>
<span class="sd">        polytopes in a region to use in</span>
<span class="sd">        reachability analysis.</span>
<span class="sd">    @param use_all_horizon:</span>
<span class="sd">        in closed-loop algorithm:</span>
<span class="sd">        if we should look for reachability also</span>
<span class="sd">        in less than `N` steps.</span>
<span class="sd">    @param trans_length:</span>
<span class="sd">        the number of polytopes</span>
<span class="sd">        allowed to cross in a transition.</span>
<span class="sd">        A value of `1` checks transitions</span>
<span class="sd">        only between neighbors, a value of `2` checks</span>
<span class="sd">        neighbors of neighbors and so on.</span>
<span class="sd">    @param remove_trans:</span>
<span class="sd">        if `True`, then remove</span>
<span class="sd">        the found transitions between non-neighbors.</span>
<span class="sd">    @param abs_tol:</span>
<span class="sd">        maximum volume for an &quot;empty&quot; polytope</span>
<span class="sd">    @param plotit:</span>
<span class="sd">        plot partitioning as it evolves</span>
<span class="sd">    @param save_img:</span>
<span class="sd">        save snapshots of partitioning</span>
<span class="sd">        to PDF files,</span>
<span class="sd">        requires `plotit=True`</span>
<span class="sd">    @param cont_props:</span>
<span class="sd">        continuous propositions to plot</span>
<span class="sd">    @param simu_type:</span>
<span class="sd">        - `&#39;bi&#39;` (default): use bisimulation partition</span>
<span class="sd">        - `&#39;dual&#39;`: use dual-simulation partition</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">match</span> <span class="n">simu_type</span><span class="p">:</span>
        <span class="k">case</span> <span class="s1">&#39;bi&#39;</span><span class="p">:</span>
            <span class="n">_discretize</span> <span class="o">=</span> <span class="n">_discretize_bi</span>
        <span class="k">case</span> <span class="s1">&#39;dual&#39;</span><span class="p">:</span>
            <span class="n">_discretize</span> <span class="o">=</span> <span class="n">_discretize_dual</span>
        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Unknown simulation &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;type: &quot;</span><span class="si">{</span><span class="n">simu_type</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_discretize</span><span class="p">(</span>
        <span class="n">part</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">min_cell_volume</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="p">,</span> <span class="n">conservative</span><span class="p">,</span>
        <span class="n">max_num_poly</span><span class="p">,</span> <span class="n">use_all_horizon</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="p">,</span> <span class="n">remove_trans</span><span class="p">,</span>
        <span class="n">abs_tol</span><span class="p">,</span>
        <span class="n">plotit</span><span class="p">,</span> <span class="n">save_img</span><span class="p">,</span> <span class="n">cont_props</span><span class="p">,</span>
        <span class="n">plot_every</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_discretize_bi</span><span class="p">(</span>
        <span class="n">part</span><span class="p">:</span>
            <span class="n">PPP</span><span class="p">,</span>
        <span class="n">ssys</span><span class="p">:</span>
            <span class="n">SystemDynamics</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">conservative</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_num_poly</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">use_all_horizon</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">remove_trans</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">abs_tol</span><span class="p">:</span>
            <span class="nb">float</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
        <span class="n">plotit</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_img</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cont_props</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="n">pc</span><span class="o">.</span><span class="n">Polytope</span><span class="p">]</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_every</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractPwa</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Refine partition, based on reachability analysis.</span>

<span class="sd">    Refines the partition, and establishes transitions</span>
<span class="sd">    based on reachability analysis. Use bi-simulation algorithm.</span>


<span class="sd">    Reference</span>
<span class="sd">    =========</span>
<span class="sd">    1. [NOTM12](</span>
<span class="sd">        https://tulip-control.sourceforge.io/doc/bibliography.html#notm12)</span>
<span class="sd">    2. Wagenmaker, A. J.; Ozay, N.</span>
<span class="sd">       &quot;A Bisimulation-like Algorithm for Abstracting Control Systems.&quot;</span>
<span class="sd">       54th Annual Allerton Conference on CCC 2016</span>


<span class="sd">    Relevant</span>
<span class="sd">    ========</span>
<span class="sd">    `prop2partition.pwa_partition`,</span>
<span class="sd">    `prop2partition.part2convex`</span>


<span class="sd">    @param N:</span>
<span class="sd">        horizon length</span>
<span class="sd">    @param min_cell_volume:</span>
<span class="sd">        the minimum volume of</span>
<span class="sd">        cells in the resulting partition.</span>
<span class="sd">    @param closed_loop:</span>
<span class="sd">        boolean indicating whether</span>
<span class="sd">        the `closed loop` algorithm should be used.</span>
<span class="sd">        (default is `True`)</span>
<span class="sd">    @param conservative:</span>
<span class="sd">        - `True`: force sequence in reachability</span>
<span class="sd">          analysis to stay inside the starting cell</span>
<span class="sd">        - `False` (default): safety is ensured by keeping</span>
<span class="sd">          the sequence inside a convexified version of</span>
<span class="sd">          the original proposition-preserving cell.</span>
<span class="sd">    @param max_num_poly:</span>
<span class="sd">        maximum number of polytopes</span>
<span class="sd">        in a region to use in reachability analysis.</span>
<span class="sd">    @param use_all_horizon:</span>
<span class="sd">        in closed-loop algorithm:</span>
<span class="sd">        if we should look for reachability also</span>
<span class="sd">        in less than `N` steps.</span>
<span class="sd">    @param trans_length:</span>
<span class="sd">        the number of polytopes allowed</span>
<span class="sd">        to cross in a transition.</span>
<span class="sd">        A value of `1` checks transitions</span>
<span class="sd">        only between neighbors, a value of `2` checks</span>
<span class="sd">        neighbors of neighbors and so on.</span>
<span class="sd">    @param remove_trans:</span>
<span class="sd">        if `True`, then remove</span>
<span class="sd">        the found transitions between non-neighbors.</span>
<span class="sd">    @param abs_tol:</span>
<span class="sd">        maximum volume for an &quot;empty&quot; polytope</span>
<span class="sd">    @param plotit:</span>
<span class="sd">        plot partitioning as it evolves</span>
<span class="sd">    @param save_img:</span>
<span class="sd">        save snapshots of partitioning</span>
<span class="sd">        to PDF files,</span>
<span class="sd">        `requires plotit=True`</span>
<span class="sd">    @param cont_props:</span>
<span class="sd">        continuous propositions to plot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_ppp</span> <span class="o">=</span> <span class="n">part</span>
    <span class="n">min_cell_volume</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">min_cell_volume</span> <span class="o">/</span>
        <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span> <span class="o">*</span>
        <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">ispwa</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">_hyb</span><span class="o">.</span><span class="n">PwaSysDyn</span><span class="p">)</span>
    <span class="n">islti</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">_hyb</span><span class="o">.</span><span class="n">LtiSysDyn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="n">part</span><span class="p">,</span> <span class="n">ppp2pwa</span><span class="p">,</span> <span class="n">part2orig</span> <span class="o">=</span> <span class="n">_p2p</span><span class="o">.</span><span class="n">pwa_partition</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
    <span class="c1"># Save original polytopes, require them to be convex</span>
    <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span><span class="p">,</span> <span class="n">new2old</span> <span class="o">=</span> <span class="n">_p2p</span><span class="o">.</span><span class="n">part2convex</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="c1"># convexify</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>
        <span class="c1"># map new regions to pwa subsystems</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ppp2pwa</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppp2pwa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>
        <span class="n">remove_trans</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># already allowed in nonconservative</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;problem in convexification&#39;</span><span class="p">)</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_list</span><span class="p">)))</span>
    <span class="c1"># Cheby radius of disturbance set</span>
    <span class="c1"># (defined within the loop for pwa systems)</span>
    <span class="k">if</span> <span class="n">islti</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssys</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">Wset</span><span class="o">.</span><span class="n">chebR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c1"># Initialize matrix for pairs to check</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Starting IJ: </span><span class="se">\n</span><span class="si">{</span><span class="n">IJ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># next line omitted in discretize_overlap</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span>
        <span class="n">trans_length</span><span class="p">,</span> <span class="n">IJ</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
    <span class="c1"># Initialize output</span>
    <span class="n">num_regions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">[</span><span class="n">num_regions</span><span class="p">,</span> <span class="n">num_regions</span><span class="p">],</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">regions</span><span class="p">)</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="c1"># next 2 lines omitted in discretize_overlap</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ppp2pwa</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span>
    <span class="c1"># init graphics</span>
    <span class="k">if</span> <span class="n">plotit</span><span class="p">:</span>
        <span class="n">_graphics</span><span class="o">.</span><span class="n">_assert_pyplot</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">file_extension</span> <span class="o">=</span> <span class="s1">&#39;pdf&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># List of how many &quot;new&quot; regions</span>
    <span class="c1"># have been created for each region</span>
    <span class="c1"># and a `list` of original number of neighbors</span>
    <span class="c1"># num_new_reg = np.zeros(len(orig_list))</span>
    <span class="c1"># num_orig_neigh = np.sum(adj, axis=1).flatten() - 1</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># Do the abstraction</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span>
        <span class="c1"># `i`, `j` swapped in discretize_overlap</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IJ</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">si_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="n">sj_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">list_subsys</span><span class="p">[</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rd</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">Wset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
            <span class="c1"># Don&#39;t use trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use original cell as trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="n">orig_list</span><span class="p">[</span><span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">S0</span> <span class="o">=</span> <span class="n">_fsb</span><span class="o">.</span><span class="n">solve_feasible</span><span class="p">(</span>
            <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">closed_loop</span><span class="p">,</span>
            <span class="n">use_all_horizon</span><span class="p">,</span> <span class="n">trans_set</span><span class="p">,</span>
            <span class="n">max_num_poly</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Working with partition cells: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> (#polytopes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="p">)</span><span class="si">}</span><span class="s1">), and:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> (#polytopes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span><span class="si">}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> with active subsystem: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Computed reachable set S0 with volume: &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">S0</span><span class="o">.</span><span class="n">volume</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># _logger.debug(r&#39;si \cap s0&#39;)</span>
        <span class="n">isect</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">vol1</span> <span class="o">=</span> <span class="n">isect</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">risect</span><span class="p">,</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
        <span class="c1"># _logger.debug(r&#39;si \ s0&#39;)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">vol2</span> <span class="o">=</span> <span class="n">diff</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">rdiff</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="c1"># if pc.is_fulldim(pc.Region([isect]).intersect(diff)):</span>
        <span class="c1">#     logging.getLogger(&#39;tulip.polytope&#39;).setLevel(logging.DEBUG)</span>
        <span class="c1">#     diff = pc.mldivide(si, S0, save=True)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = S0.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/s0.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = si.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/si.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = isect.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/isect.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = diff.plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/diff.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     ax = isect.intersect(diff).plot()</span>
        <span class="c1">#     ax.axis([0.0, 1.0, 0.0, 2.0])</span>
        <span class="c1">#     ax.figure.savefig(&#39;./img/diff_cap_isect.pdf&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     _logger.error(r&#39;Intersection \cap Difference != \emptyset&#39;)</span>
        <span class="c1">#</span>
        <span class="c1">#     assert(False)</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1">cap Pre(sj), &#39;</span>
                <span class="s1">&#39;so discard intersection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span> <span class="ow">and</span> <span class="n">isect</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> discarded non-empty intersection: &#39;</span>
                <span class="s1">&#39;consider reducing min_cell_volume&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol2</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1"> Pre(sj), so not reached it&#39;</span><span class="p">)</span>
        <span class="c1"># We don&#39;t want our partitions to</span>
        <span class="c1"># be smaller than the disturbance set</span>
        <span class="c1"># Could be a problem since cheby</span>
        <span class="c1"># radius is calculated for smallest</span>
        <span class="c1"># convex polytope, so if we have</span>
        <span class="c1"># a region we might throw away a good cell.</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">vol1</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">risect</span> <span class="o">&gt;</span> <span class="n">rd</span> <span class="ow">and</span>
                <span class="n">vol2</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">rdiff</span> <span class="o">&gt;</span> <span class="n">rd</span><span class="p">):</span>
            <span class="c1"># Make sure new areas are Regions</span>
            <span class="c1"># and add proposition lists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">isect</span><span class="p">],</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">isect</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">diff</span><span class="p">],</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">diff</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># replace si by intersection (single state)</span>
            <span class="n">isect_list</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">isect_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># cut difference into connected pieces</span>
            <span class="n">difflist</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
            <span class="n">difflist</span> <span class="o">+=</span> <span class="n">isect_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># n_isect = len(isect_list) - 1</span>
            <span class="n">num_new</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">difflist</span><span class="p">)</span>
            <span class="c1"># add each piece, as a new state</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">difflist</span><span class="p">:</span>
                <span class="n">sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
                <span class="c1"># keep track of PWA subsystems map to new states</span>
                <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
                    <span class="n">subsys_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
            <span class="n">new_idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span>
                <span class="n">n_cells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">n_cells</span> <span class="o">-</span> <span class="n">num_new</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="c1"># Update transition matrix</span>
            <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">transitions</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_new</span><span class="p">),</span>
                <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_cells</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="c1">#transitions[:, r] = transitions[:, i]</span>
                <span class="c1"># All sets reachable from star</span>
                <span class="c1"># are reachable from both part&#39;s</span>
                <span class="c1"># except possibly the new part</span>
                <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># `sol[j]` is reachable from</span>
            <span class="c1"># intersection of `sol[i]` and `S0`</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># `sol[j]` is reachable from</span>
                <span class="c1"># each piece of `S0 \cap sol[i]`</span>
                <span class="c1"># for k in range(n_cells - n_isect - 2, n_cells):</span>
                <span class="c1">#    transitions[j, k] = 1</span>
            <span class="c1">#</span>
            <span class="c1"># Update adjacency matrix</span>
            <span class="n">old_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># reset new adjacencies</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_cells</span> <span class="o">-</span> <span class="n">num_new</span><span class="p">])</span>
            <span class="n">adj</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_cells</span> <span class="o">-</span> <span class="n">num_new</span><span class="p">])</span>
            <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">adj</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_new</span><span class="p">),</span>
                <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">conservative</span><span class="p">:</span>
                    <span class="n">orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">orig</span><span class="p">,</span> <span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="c1"># adjacency between pieces of `isect` and `diff`</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="n">k</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\n</span><span class="s1"> Adding states </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> and &#39;</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">r</span><span class="si">}</span><span class="s1"> and &#39;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">old_adj</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n_cells</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="c1"># Every &quot;old&quot; neighbor must be the neighbor</span>
                <span class="c1"># of at least one of the new</span>
                <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">elif</span> <span class="n">remove_trans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trans_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="c1"># Actively remove transitions</span>
                    <span class="c1"># between non-neighbors</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">r</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">remove_trans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trans_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Actively remove transitions</span>
                        <span class="c1"># between non-neighbors</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1">#</span>
            <span class="c1"># Update IJ matrix</span>
            <span class="n">IJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                <span class="n">IJ</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_new</span><span class="p">),</span>
                <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
            <span class="n">adj_k</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span>
            <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">new_idx</span><span class="p">:</span>
                <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated adj: </span><span class="se">\n</span><span class="si">{</span><span class="n">adj</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated trans: </span><span class="se">\n</span><span class="si">{</span><span class="n">transitions</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated IJ: </span><span class="se">\n</span><span class="si">{</span><span class="n">IJ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Divided region: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">vol2</span> <span class="o">&lt;</span> <span class="n">abs_tol</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> ---&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Unreachable: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> --X--&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> diff vol: </span><span class="si">{</span><span class="n">vol2</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> intersect vol: </span><span class="si">{</span><span class="n">vol1</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> unreachable</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check to avoid overlapping Regions</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span>
                <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
                <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">tmp_part</span><span class="o">.</span><span class="n">is_partition</span><span class="p">())</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="n">progress_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_cells</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">progress_ratio</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> total # polytopes: </span><span class="si">{</span><span class="n">n_cells</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> progress ratio: </span><span class="si">{</span><span class="n">progress_ratio</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># no plotting ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plotit</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">plt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_pplt</span><span class="o">.</span><span class="n">plot_partition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">iter_count</span> <span class="o">%</span> <span class="n">plot_every</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
            <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
        <span class="c1"># plot pair under reachability check</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">si_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
        <span class="n">sj_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">_pplt</span><span class="o">.</span><span class="n">plot_transition_arrow</span><span class="p">(</span><span class="n">si_tmp</span><span class="p">,</span> <span class="n">sj_tmp</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span>
        <span class="n">S0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># plot partition</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_pplt</span><span class="o">.</span><span class="n">plot_partition</span><span class="p">(</span>
            <span class="n">tmp_part</span><span class="p">,</span>
            <span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span>
            <span class="n">color_seed</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
        <span class="c1"># plot dynamics</span>
        <span class="n">ssys</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">show_domain</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># plot hatched continuous propositions</span>
        <span class="n">part</span><span class="o">.</span><span class="n">plot_props</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># scale view based on domain,</span>
        <span class="c1"># not only the current polytopes si, sj</span>
        <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">save_img</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;movie</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">iter_count</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;.</span><span class="si">{</span><span class="n">file_extension</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_part</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
        <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
        <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
        <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
    <span class="c1"># check completeness of adjacency matrix</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">new_part</span><span class="p">)</span>
        <span class="n">tmp_part</span><span class="o">.</span><span class="n">compute_adj</span><span class="p">()</span>
    <span class="c1"># Generate transition system and add transitions</span>
    <span class="n">ofts</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FTS</span><span class="p">()</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ofts_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add_adj</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">ofts_states</span><span class="p">)</span>
    <span class="c1"># Decorate TS with state labels</span>
    <span class="n">atomic_propositions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">atomic_propositions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="n">state_prop</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="n">state_prop</span><span class="p">)</span>
    <span class="n">param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="o">=</span><span class="n">trans_length</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="o">=</span><span class="n">closed_loop</span><span class="p">,</span>
        <span class="n">conservative</span><span class="o">=</span><span class="n">conservative</span><span class="p">,</span>
        <span class="n">use_all_horizon</span><span class="o">=</span><span class="n">use_all_horizon</span><span class="p">,</span>
        <span class="n">min_cell_volume</span><span class="o">=</span><span class="n">min_cell_volume</span><span class="p">,</span>
        <span class="n">max_num_poly</span><span class="o">=</span><span class="n">max_num_poly</span><span class="p">)</span>
    <span class="n">ppp2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orig</span><span class="p">]</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Total abstraction time: </span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s1">[sec]&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_img</span> <span class="ow">and</span> <span class="n">plt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;progress ratio&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;progress.pdf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AbstractPwa</span><span class="p">(</span>
        <span class="n">ppp</span><span class="o">=</span><span class="n">new_part</span><span class="p">,</span>
        <span class="n">ts</span><span class="o">=</span><span class="n">ofts</span><span class="p">,</span>
        <span class="n">ppp2ts</span><span class="o">=</span><span class="n">ofts_states</span><span class="p">,</span>
        <span class="n">pwa</span><span class="o">=</span><span class="n">ssys</span><span class="p">,</span>
        <span class="n">pwa_ppp</span><span class="o">=</span><span class="n">part</span><span class="p">,</span>
        <span class="n">ppp2pwa</span><span class="o">=</span><span class="n">orig</span><span class="p">,</span>
        <span class="n">ppp2sys</span><span class="o">=</span><span class="n">subsys_list</span><span class="p">,</span>
        <span class="n">orig_ppp</span><span class="o">=</span><span class="n">orig_ppp</span><span class="p">,</span>
        <span class="n">ppp2orig</span><span class="o">=</span><span class="n">ppp2orig</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_discretize_dual</span><span class="p">(</span>
        <span class="n">part</span><span class="p">:</span>
            <span class="n">PPP</span><span class="p">,</span>
        <span class="n">ssys</span><span class="p">:</span>
            <span class="n">SystemDynamics</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="nb">float</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">conservative</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">max_num_poly</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
        <span class="n">use_all_horizon</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">remove_trans</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">abs_tol</span><span class="p">:</span>
            <span class="nb">float</span><span class="o">=</span><span class="mf">1e-7</span><span class="p">,</span>
        <span class="n">plotit</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">save_img</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">cont_props</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="n">pc</span><span class="o">.</span><span class="n">Polytope</span><span class="p">]</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_every</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractPwa</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Refine partition, based on reachability analysis.</span>

<span class="sd">    Refines the partition, and establishes transitions</span>
<span class="sd">    based on reachability analysis.</span>
<span class="sd">    Uses dual-simulation algorithm.</span>


<span class="sd">    Reference</span>
<span class="sd">    =========</span>
<span class="sd">    1. [NOTM12](</span>
<span class="sd">        https://tulip-control.sourceforge.io/doc/bibliography.html#notm12)</span>
<span class="sd">    2. Wagenmaker, A. J.; Ozay, N.</span>
<span class="sd">       &quot;A Bisimulation-like Algorithm for Abstracting Control Systems.&quot;</span>
<span class="sd">       54th Annual Allerton Conference on CCC 2016</span>


<span class="sd">    Relevant</span>
<span class="sd">    ========</span>
<span class="sd">    `prop2partition.pwa_partition`,</span>
<span class="sd">    `prop2partition.part2convex`</span>


<span class="sd">    @param N:</span>
<span class="sd">        horizon length</span>
<span class="sd">    @param min_cell_volume:</span>
<span class="sd">        the minimum volume of</span>
<span class="sd">        ells in the resulting partition.</span>
<span class="sd">    @param closed_loop:</span>
<span class="sd">        `bool` indicating whether</span>
<span class="sd">        the `closed loop` algorithm should be used.</span>
<span class="sd">        (default is `True`)</span>
<span class="sd">    @param conservative:</span>
<span class="sd">        - `True`: force sequence in reachability analysis</span>
<span class="sd">          to stay inside starting cell.</span>
<span class="sd">        - `False`: safety is ensured by keeping the</span>
<span class="sd">          sequence inside a convexified version of</span>
<span class="sd">          the original proposition-preserving cell.</span>
<span class="sd">    @param max_num_poly:</span>
<span class="sd">        maximum number of polytopes</span>
<span class="sd">        in a region to use in reachability analysis.</span>
<span class="sd">    @param use_all_horizon:</span>
<span class="sd">        in closed-loop algorithm:</span>
<span class="sd">        if we should look for reachability also in</span>
<span class="sd">        less than `N` steps.</span>
<span class="sd">    @param trans_length:</span>
<span class="sd">        the number of polytopes</span>
<span class="sd">        allowed to cross in a transition.</span>
<span class="sd">        - `1`: check transitions only between neighbors,</span>
<span class="sd">        - `2`: check neighbors of neighbors and so on.</span>
<span class="sd">    @param remove_trans:</span>
<span class="sd">        if `True`, then remove</span>
<span class="sd">        found transitions between non-neighbors.</span>
<span class="sd">    @param abs_tol:</span>
<span class="sd">        maximum volume for an &quot;empty&quot; polytope</span>
<span class="sd">    @param plotit:</span>
<span class="sd">        plot partitioning as it evolves</span>
<span class="sd">    @param save_img:</span>
<span class="sd">        save snapshots of partitioning</span>
<span class="sd">        to PDF files,</span>
<span class="sd">        requires `plotit=True`</span>
<span class="sd">    @param cont_props:</span>
<span class="sd">        continuous propositions to plot</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_ppp</span> <span class="o">=</span> <span class="n">part</span>
    <span class="n">min_cell_volume</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">min_cell_volume</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
        <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
    <span class="n">ispwa</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">_hyb</span><span class="o">.</span><span class="n">PwaSysDyn</span><span class="p">)</span>
    <span class="n">islti</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">_hyb</span><span class="o">.</span><span class="n">LtiSysDyn</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="n">part</span><span class="p">,</span> <span class="n">ppp2pwa</span><span class="p">,</span> <span class="n">part2orig</span> <span class="o">=</span> <span class="n">_p2p</span><span class="o">.</span><span class="n">pwa_partition</span><span class="p">(</span><span class="n">ssys</span><span class="p">,</span> <span class="n">part</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">))</span>
    <span class="c1"># Save original polytopes, require them to be convex</span>
    <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">part</span><span class="p">,</span> <span class="n">new2old</span> <span class="o">=</span> <span class="n">_p2p</span><span class="o">.</span><span class="n">part2convex</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>  <span class="c1"># convexify</span>
        <span class="n">part2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>
        <span class="c1"># map new regions to pwa subsystems</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ppp2pwa</span> <span class="o">=</span> <span class="p">[</span><span class="n">ppp2pwa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">new2old</span><span class="p">]</span>
        <span class="n">remove_trans</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># already allowed in nonconservative</span>
        <span class="n">orig_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">part</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">orig_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;problem in convexification&#39;</span><span class="p">)</span>
        <span class="n">orig</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_list</span><span class="p">)))</span>
    <span class="c1"># Cheby radius of disturbance set</span>
    <span class="c1"># (defined within the loop for pwa systems)</span>
    <span class="k">if</span> <span class="n">islti</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssys</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">Wset</span><span class="o">.</span><span class="n">chebR</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="c1"># Initialize matrix for pairs to check</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Starting IJ: </span><span class="se">\n</span><span class="si">{</span><span class="n">IJ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># next line omitted in discretize_overlap</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span>
        <span class="n">trans_length</span><span class="p">,</span> <span class="n">IJ</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">toarray</span><span class="p">())</span>
    <span class="c1"># Initialize output</span>
    <span class="n">num_regions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">[</span><span class="n">num_regions</span><span class="p">,</span> <span class="n">num_regions</span><span class="p">],</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">regions</span><span class="p">)</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
    <span class="c1"># next 2 lines omitted in `discretize_overlap`</span>
    <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ppp2pwa</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsys_list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span>
    <span class="c1"># init graphics</span>
    <span class="k">if</span> <span class="n">plotit</span><span class="p">:</span>
        <span class="n">_graphics</span><span class="o">.</span><span class="n">_assert_pyplot</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ion</span><span class="p">()</span>
        <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;scaled&#39;</span><span class="p">)</span>
        <span class="n">file_extension</span> <span class="o">=</span> <span class="s1">&#39;pdf&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">iter_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># List of how many &quot;new&quot; regions</span>
    <span class="c1"># have been created for each region</span>
    <span class="c1"># and a `list` of original number of neighbors</span>
    <span class="c1"># num_new_reg = np.zeros(len(orig_list))</span>
    <span class="c1"># num_orig_neigh = np.sum(adj, axis=1).flatten() - 1</span>
    <span class="n">progress</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="c1"># Do the abstraction</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span>
        <span class="c1"># `i`, `j` swapped in `discretize_overlap`</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IJ</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">si_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="n">sj_tmp</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span>
        <span class="c1"># num_new_reg[i] += 1</span>
        <span class="c1"># print(num_new_reg)</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="n">ssys</span><span class="o">.</span><span class="n">list_subsys</span><span class="p">[</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">rd</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">Wset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rd</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="k">if</span> <span class="n">conservative</span><span class="p">:</span>
            <span class="c1"># Don&#39;t use trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use original cell as trans_set</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="n">orig_list</span><span class="p">[</span><span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">S0</span> <span class="o">=</span> <span class="n">_fsb</span><span class="o">.</span><span class="n">solve_feasible</span><span class="p">(</span>
            <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">closed_loop</span><span class="p">,</span>
            <span class="n">use_all_horizon</span><span class="p">,</span> <span class="n">trans_set</span><span class="p">,</span> <span class="n">max_num_poly</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Working with partition cells: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> (#polytopes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">si</span><span class="p">)</span><span class="si">}</span><span class="s1">), and:</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> (#polytopes = </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sj</span><span class="p">)</span><span class="si">}</span><span class="s1">)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ispwa</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> with active subsystem: &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">subsys_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Computed reachable set S0 with volume: &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">S0</span><span class="o">.</span><span class="n">volume</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># _logger.debug(r&#39;si \cap s0&#39;)</span>
        <span class="n">isect</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">S0</span><span class="p">)</span>
        <span class="n">vol1</span> <span class="o">=</span> <span class="n">isect</span><span class="o">.</span><span class="n">volume</span>
        <span class="n">risect</span><span class="p">,</span> <span class="n">xi</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
        <span class="c1"># _logger.debug(r&#39;si \ s0&#39;)</span>
        <span class="n">rsi</span><span class="p">,</span> <span class="n">xd</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">si</span><span class="p">)</span>
        <span class="n">vol2</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">volume</span> <span class="o">-</span> <span class="n">vol1</span>
            <span class="c1"># not accurate.</span>
            <span class="c1"># need to check polytope class</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1">cap Pre(sj), &#39;</span>
                <span class="s1">&#39;so discard intersection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol1</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span> <span class="ow">and</span> <span class="n">isect</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> discarded non-empty intersection: &#39;</span>
                <span class="s1">&#39;consider reducing min_cell_volume&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vol2</span> <span class="o">&lt;=</span> <span class="n">min_cell_volume</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> too small: si </span><span class="se">\\</span><span class="s1"> Pre(sj), &#39;</span>
                <span class="s1">&#39;so not reached it&#39;</span><span class="p">)</span>
        <span class="c1"># indicate if S0 has exists in sol</span>
        <span class="n">check_isect</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># We don&#39;t want our partitions to be</span>
        <span class="c1"># smaller than the disturbance set</span>
        <span class="c1"># Could be a problem since cheby radius</span>
        <span class="c1"># is calculated for smallest</span>
        <span class="c1"># convex polytope, so if we have a region</span>
        <span class="c1"># we might throw away a good cell.</span>
        <span class="k">if</span> <span class="p">(</span>
                <span class="n">vol1</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">risect</span> <span class="o">&gt;</span> <span class="n">rd</span> <span class="ow">and</span>
                <span class="n">vol2</span> <span class="o">&gt;</span> <span class="n">min_cell_volume</span> <span class="ow">and</span>
                <span class="n">rsi</span> <span class="o">&gt;</span> <span class="n">rd</span><span class="p">):</span>
            <span class="c1"># check if the intersection has</span>
            <span class="c1"># existed in current partitions</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)):</span>
                <span class="k">if</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">isect</span><span class="p">):</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Found: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s1"> ---&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1"> &#39;</span>
                        <span class="s1">&#39;intersection exists.</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">check_isect</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_isect</span><span class="p">:</span>
                <span class="c1"># Make sure new areas are Regions</span>
                <span class="c1"># and add proposition lists</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">isect</span><span class="p">],</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">isect</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># add intersection in sol</span>
                <span class="n">isect_list</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">separate</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
                <span class="n">sol</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
                <span class="n">new_idx</span> <span class="o">=</span> <span class="n">n_cells</span><span class="o">-</span><span class="mi">1</span>
                <span class="c1">#</span>
                <span class="c1"># Update adjacency matrix</span>
                <span class="n">old_adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:])[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                <span class="c1"># cell i and new_idx are adjacent</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">conservative</span><span class="p">:</span>
                    <span class="n">orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">orig</span><span class="p">,</span> <span class="n">orig</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\n</span><span class="s1"> Adding states </span><span class="si">{</span><span class="n">new_idx</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">old_adj</span><span class="p">,</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n_cells</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="c1"># Every &quot;old&quot; neighbor must be the neighbor</span>
                    <span class="c1"># of at least one of the new</span>
                    <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">sol</span><span class="p">[</span><span class="n">new_idx</span><span class="p">],</span> <span class="n">sol</span><span class="p">[</span><span class="n">k</span><span class="p">]):</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">adj</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">elif</span> <span class="n">remove_trans</span> <span class="ow">and</span> <span class="p">(</span><span class="n">trans_length</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Actively remove transitions</span>
                        <span class="c1"># between non-neighbors</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">new_idx</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="c1"># Update transition matrix</span>
                <span class="n">transitions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span>
                    <span class="n">transitions</span><span class="p">,</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                <span class="n">adj_k</span> <span class="o">=</span> <span class="n">reachable_within</span><span class="p">(</span><span class="n">trans_length</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span>
                <span class="c1"># transitions `i` ---&gt; `k` for `k` is</span>
                <span class="c1"># neighbor of `new_idx` should be</span>
                <span class="c1"># kept by `new_idx`</span>
                <span class="n">transitions</span><span class="p">[:,</span> <span class="n">new_idx</span>
                    <span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span>
                        <span class="n">transitions</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                        <span class="n">adj_k</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
                <span class="c1"># if `j` and `new_idx` are neighbors,</span>
                <span class="c1"># then add `new_idx` ---&gt; `j`</span>
                <span class="k">if</span> <span class="n">adj_k</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1">#</span>
                <span class="c1"># Update IJ matrix</span>
                <span class="n">IJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39;constant&#39;</span><span class="p">)</span>
                <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                <span class="n">sym_adj_change</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">adj_k</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">new_idx</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated adj: </span><span class="se">\n</span><span class="si">{</span><span class="n">adj</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated trans: </span><span class="se">\n</span><span class="si">{</span><span class="n">transitions</span><span class="si">}</span><span class="s1">&#39;</span>
                        <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1"> Updated IJ: </span><span class="se">\n</span><span class="si">{</span><span class="n">IJ</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Divided region: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">vol2</span> <span class="o">&lt;</span> <span class="n">abs_tol</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> ---&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Unreachable: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> --X--&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> diff vol: </span><span class="si">{</span><span class="n">vol2</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t\t</span><span class="s1"> intersect vol: </span><span class="si">{</span><span class="n">vol1</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> unreachable</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># check to avoid overlapping Regions</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
                <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
                <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
                <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
            <span class="k">assert</span><span class="p">(</span><span class="n">tmp_part</span><span class="o">.</span><span class="n">is_partition</span><span class="p">())</span>
        <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sol</span><span class="p">)</span>
        <span class="n">progress_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">))</span> <span class="o">/</span> <span class="n">n_cells</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">progress</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">progress_ratio</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> total # polytopes: </span><span class="si">{</span><span class="n">n_cells</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> progress ratio: </span><span class="si">{</span><span class="n">progress_ratio</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">iter_count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># needs to be removed later</span>
        <span class="c1"># if(iter_count&gt;=700):</span>
        <span class="c1"># break</span>
        <span class="c1"># no plotting ?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">plotit</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">plt</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_pplt</span><span class="o">.</span><span class="n">plot_partition</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">iter_count</span> <span class="o">%</span> <span class="n">plot_every</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
            <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
            <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
            <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
        <span class="c1"># plot pair under reachability check</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">si_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>
        <span class="n">sj_tmp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">_pplt</span><span class="o">.</span><span class="n">plot_transition_arrow</span><span class="p">(</span><span class="n">si_tmp</span><span class="p">,</span> <span class="n">sj_tmp</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span>
        <span class="n">S0</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># plot partition</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">_pplt</span><span class="o">.</span><span class="n">plot_partition</span><span class="p">(</span>
            <span class="n">tmp_part</span><span class="p">,</span>
            <span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">,</span>
            <span class="n">color_seed</span><span class="o">=</span><span class="mi">23</span><span class="p">)</span>
        <span class="c1"># plot dynamics</span>
        <span class="n">ssys</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">show_domain</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># plot hatched continuous propositions</span>
        <span class="n">part</span><span class="o">.</span><span class="n">plot_props</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="c1"># scale view based on domain,</span>
        <span class="c1"># not only the current polytopes si, sj</span>
        <span class="n">l</span><span class="p">,</span><span class="n">u</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">save_img</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;movie</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">iter_count</span><span class="p">)</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;.</span><span class="si">{</span><span class="n">file_extension</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">250</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">pause</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">new_part</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
        <span class="n">domain</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
        <span class="n">regions</span><span class="o">=</span><span class="n">sol</span><span class="p">,</span> <span class="n">adj</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">adj</span><span class="p">),</span>
        <span class="n">prop_regions</span><span class="o">=</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
    <span class="c1"># check completeness of adjacency matrix</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="n">tmp_part</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">new_part</span><span class="p">)</span>
        <span class="n">tmp_part</span><span class="o">.</span><span class="n">compute_adj</span><span class="p">()</span>
    <span class="c1"># Generate transition system and add transitions</span>
    <span class="n">ofts</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FTS</span><span class="p">()</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span><span class="n">transitions</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">adj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ofts_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add_adj</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">ofts_states</span><span class="p">)</span>
    <span class="c1"># Decorate TS with state labels</span>
    <span class="n">atomic_propositions</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">part</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">)</span>
    <span class="n">ofts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">atomic_propositions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">state</span><span class="p">,</span> <span class="n">region</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ofts_states</span><span class="p">,</span> <span class="n">sol</span><span class="p">):</span>
        <span class="n">state_prop</span> <span class="o">=</span> <span class="n">region</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ofts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ap</span><span class="o">=</span><span class="n">state_prop</span><span class="p">)</span>
    <span class="n">param</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="o">=</span><span class="n">trans_length</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="o">=</span><span class="n">closed_loop</span><span class="p">,</span>
        <span class="n">conservative</span><span class="o">=</span><span class="n">conservative</span><span class="p">,</span>
        <span class="n">use_all_horizon</span><span class="o">=</span><span class="n">use_all_horizon</span><span class="p">,</span>
        <span class="n">min_cell_volume</span><span class="o">=</span><span class="n">min_cell_volume</span><span class="p">,</span>
        <span class="n">max_num_poly</span><span class="o">=</span><span class="n">max_num_poly</span><span class="p">)</span>
    <span class="n">ppp2orig</span> <span class="o">=</span> <span class="p">[</span><span class="n">part2orig</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">orig</span><span class="p">]</span>
    <span class="n">end_time</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">times</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">end_time</span> <span class="o">-</span> <span class="n">start_time</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;Total abstraction time: </span><span class="si">{</span><span class="n">dt</span><span class="si">}</span><span class="s1"> [sec]&#39;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">save_img</span> <span class="ow">and</span> <span class="n">plt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">progress</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;iteration&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;progress ratio&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;progress.pdf&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AbstractPwa</span><span class="p">(</span>
        <span class="n">ppp</span><span class="o">=</span><span class="n">new_part</span><span class="p">,</span>
        <span class="n">ts</span><span class="o">=</span><span class="n">ofts</span><span class="p">,</span>
        <span class="n">ppp2ts</span><span class="o">=</span><span class="n">ofts_states</span><span class="p">,</span>
        <span class="n">pwa</span><span class="o">=</span><span class="n">ssys</span><span class="p">,</span>
        <span class="n">pwa_ppp</span><span class="o">=</span><span class="n">part</span><span class="p">,</span>
        <span class="n">ppp2pwa</span><span class="o">=</span><span class="n">orig</span><span class="p">,</span>
        <span class="n">ppp2sys</span><span class="o">=</span><span class="n">subsys_list</span><span class="p">,</span>
        <span class="n">orig_ppp</span><span class="o">=</span><span class="n">orig_ppp</span><span class="p">,</span>
        <span class="n">ppp2orig</span><span class="o">=</span><span class="n">ppp2orig</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="o">=</span><span class="n">param</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">reachable_within</span><span class="p">(</span>
        <span class="n">trans_length</span><span class="p">:</span>
            <span class="nb">int</span><span class="p">,</span>
        <span class="n">adj_k</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">adj</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find cells reachable within trans_length hops.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">trans_length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">adj_k</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">trans_length</span><span class="p">:</span>
        <span class="n">adj_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">adj_k</span><span class="p">,</span> <span class="n">adj</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">adj_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">adj_k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adj_k</span>


<span class="k">def</span> <span class="nf">sym_adj_change</span><span class="p">(</span>
        <span class="n">IJ</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">adj_k</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">transitions</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">i</span><span class="p">:</span>
            <span class="nb">int</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">horizontal</span> <span class="o">=</span> <span class="n">adj_k</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">vertical</span> <span class="o">=</span> <span class="n">adj_k</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">transitions</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">IJ</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">horizontal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">IJ</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">vertical</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>


<span class="c1"># DEFUNCT until further notice</span>
<span class="k">def</span> <span class="nf">discretize_overlap</span><span class="p">(</span>
        <span class="n">closed_loop</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">conservative</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PPP</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;default False.</span>

<span class="sd">    UNDER DEVELOPMENT; function signature may change without notice.</span>
<span class="sd">    Calling will result in NotImplementedError.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
<span class="c1">#</span>
<span class="c1">#         if rdiff &lt; abs_tol:</span>
<span class="c1">#             _logger.info(&quot;Transition found&quot;)</span>
<span class="c1">#             transitions[i,j] = 1</span>
<span class="c1">#</span>
<span class="c1">#         elif ((vol1 &gt; min_cell_volume) &amp; (risect &gt; rd) &amp;</span>
<span class="c1">#                 (num_new_reg[i] &lt;= num_orig_neigh[i]+1)):</span>
<span class="c1">#</span>
<span class="c1">#             # Make sure new cell is Region and add proposition lists</span>
<span class="c1">#             if len(isect) == 0:</span>
<span class="c1">#                 isect = pc.Region([isect], si.props)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 isect.props = si.props.copy()</span>
<span class="c1">#</span>
<span class="c1">#             # Add new state</span>
<span class="c1">#             sol.append(isect)</span>
<span class="c1">#             size = len(sol)</span>
<span class="c1">#</span>
<span class="c1">#             # Add transitions</span>
<span class="c1">#             transitions = np.hstack([transitions, np.zeros([size - 1, 1],</span>
<span class="c1">#                                     dtype=int) ])</span>
<span class="c1">#             transitions = np.vstack([transitions, np.zeros([1, size],</span>
<span class="c1">#                                     dtype=int) ])</span>
<span class="c1">#</span>
<span class="c1">#             # All sets reachable from orig cell are reachable from both cells</span>
<span class="c1">#             transitions[size-1,:] = transitions[i,:]</span>
<span class="c1">#             transitions[size-1,j] = 1   # j is reachable from new cell</span>
<span class="c1">#</span>
<span class="c1">#             # Take care of adjacency</span>
<span class="c1">#             old_adj = np.nonzero(adj[i,:])[0]</span>
<span class="c1">#</span>
<span class="c1">#             adj = np.hstack([adj, np.zeros([size - 1, 1], dtype=int) ])</span>
<span class="c1">#             adj = np.vstack([adj, np.zeros([1, size], dtype=int) ])</span>
<span class="c1">#             adj[i,size-1] = 1</span>
<span class="c1">#             adj[size-1,i] = 1</span>
<span class="c1">#             adj[size-1,size-1] = 1</span>
<span class="c1">#</span>
<span class="c1">#             for k in np.setdiff1d(old_adj,[i,size-1]):</span>
<span class="c1">#                 if pc.is_adjacent(sol[size-1],sol[k],overlap=True):</span>
<span class="c1">#                     adj[size-1,k] = 1</span>
<span class="c1">#                     adj[k, size-1] = 1</span>
<span class="c1">#                 else:</span>
<span class="c1">#                     # Actively remove (valid) transitions between non-neighbors</span>
<span class="c1">#                     transitions[size-1,k] = 0</span>
<span class="c1">#                     transitions[k,size-1] = 0</span>
<span class="c1">#</span>
<span class="c1">#             # Assign original proposition cell to new state and update counts</span>
<span class="c1">#             if not conservative:</span>
<span class="c1">#                 orig = np.hstack([orig, orig[i]])</span>
<span class="c1">#             print(num_new_reg)</span>
<span class="c1">#             num_new_reg = np.hstack([num_new_reg, 0])</span>
<span class="c1">#             num_orig_neigh = np.hstack([num_orig_neigh, np.sum(adj[size-1,:])-1])</span>
<span class="c1">#</span>
<span class="c1">#             _logger.info(f&quot;\n Adding state {size - 1}\n&quot;)</span>
<span class="c1">#</span>
<span class="c1">#             # Just add adjacent cells for checking,</span>
<span class="c1">#             # unless transition already found</span>
<span class="c1">#             IJ = np.hstack([IJ, np.zeros([size - 1, 1], dtype=int) ])</span>
<span class="c1">#             IJ = np.vstack([IJ, np.zeros([1, size], dtype=int) ])</span>
<span class="c1">#             horiz2 = adj[size-1,:] - transitions[size-1,:] &gt; 0</span>
<span class="c1">#             verti2 = adj[:,size-1] - transitions[:,size-1] &gt; 0</span>
<span class="c1">#             IJ[size-1,:] = horiz2.astype(int)</span>
<span class="c1">#             IJ[:,size-1] = verti2.astype(int)</span>
<span class="c1">#         else:</span>
<span class="c1">#             _logger.info(f&quot;No transition found, intersect vol: {vol1}&quot;)</span>
<span class="c1">#             transitions[i,j] = 0</span>
<span class="c1">#</span>
<span class="c1">#     new_part = PPP(</span>
<span class="c1">#                    domain=part.domain,</span>
<span class="c1">#                    regions=sol, adj=np.array([]),</span>
<span class="c1">#                    trans=transitions, prop_regions=part.prop_regions,</span>
<span class="c1">#                    original_regions=orig_list, orig=orig)</span>
<span class="c1">#     return new_part</span>


<span class="k">def</span> <span class="nf">multiproc_discretize</span><span class="p">(</span>
        <span class="n">q</span><span class="p">:</span>
            <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span>
            <span class="nb">str</span><span class="p">,</span>
        <span class="n">ppp</span><span class="p">:</span>
            <span class="n">PPP</span><span class="p">,</span>
        <span class="n">cont_dyn</span><span class="p">:</span>
            <span class="n">SystemDynamics</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="p">:</span>
            <span class="nb">dict</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">_logger</span>
    <span class="n">_logger</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;Abstracting mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">, on: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">absys</span> <span class="o">=</span> <span class="n">discretize</span><span class="p">(</span><span class="n">ppp</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span> <span class="o">**</span><span class="n">disc_params</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">mode</span><span class="p">,</span> <span class="n">absys</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Worker: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> finished.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">multiproc_get_transitions</span><span class="p">(</span>
        <span class="n">q</span><span class="p">:</span>
            <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">,</span>
        <span class="n">absys</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">,</span>
        <span class="n">ssys</span><span class="p">:</span>
            <span class="n">SystemDynamics</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span>
            <span class="nb">dict</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">global</span> <span class="n">_logger</span>
    <span class="n">_logger</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">log_to_stderr</span><span class="p">()</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">current_process</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="s1">&#39;Merged transitions for &#39;</span>
        <span class="sa">f</span><span class="s1">&#39;mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">, on: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="n">get_transitions</span><span class="p">(</span>
        <span class="n">absys</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ssys</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
    <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">mode</span><span class="p">,</span> <span class="n">trans</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Worker: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1"> finished.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">multiproc_discretize_switched</span><span class="p">(</span>
        <span class="n">ppp</span><span class="p">:</span>
            <span class="n">PPP</span><span class="p">,</span>
        <span class="n">hybrid_sys</span><span class="p">:</span>
            <span class="n">_hyb</span><span class="o">.</span><span class="n">SwitchedSysDyn</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="p">:</span>
            <span class="nb">dict</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">show_ts</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">only_adjacent</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractSwitched</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parallel implementation of `discretize_switched`.</span>

<span class="sd">    Uses the multiprocessing package.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;parallel `discretize_switched` started&#39;</span><span class="p">)</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hybrid_sys</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
    <span class="n">mode_nums</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">disc_domain_size</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">Queue</span><span class="p">()</span>
    <span class="n">mode_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">mode_args</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ppp</span><span class="p">,</span>
            <span class="n">cont_dyn</span><span class="p">,</span> <span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">multiproc_discretize</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">mode_args</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c1"># flush before join:</span>
    <span class="c1">#   &lt;http://stackoverflow.com/questions/19071529/&gt;</span>
    <span class="n">abstractions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">mode</span><span class="p">,</span> <span class="n">absys</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">abstractions</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">absys</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">job</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="c1"># merge their domains</span>
    <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">ap_labeling</span> <span class="o">=</span> <span class="n">merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Merged partition has: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">, states&#39;</span><span class="p">)</span>
    <span class="c1"># find feasible transitions over merged partition</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">mode_args</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">q</span><span class="p">,</span> <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">mp</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span>
            <span class="n">target</span><span class="o">=</span><span class="n">multiproc_get_transitions</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">args</span> <span class="ow">in</span> <span class="n">mode_args</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">job</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">mode</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="n">trans</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span>
    <span class="c1"># merge the abstractions, creating a common TS</span>
    <span class="n">merge_abstractions</span><span class="p">(</span>
        <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
        <span class="n">abstractions</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">mode_nums</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_mode_partitions</span><span class="p">(</span>
            <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">merged_abstr</span>


<span class="k">def</span> <span class="nf">discretize_switched</span><span class="p">(</span>
        <span class="n">ppp</span><span class="p">:</span>
            <span class="n">PPP</span><span class="p">,</span>
        <span class="n">hybrid_sys</span><span class="p">:</span>
            <span class="n">_hyb</span><span class="o">.</span><span class="n">SwitchedSysDyn</span><span class="p">,</span>
        <span class="n">disc_params</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]</span> <span class="o">|</span>
            <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">plot</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">show_ts</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">only_adjacent</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AbstractSwitched</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Abstract switched dynamics over given partition.</span>

<span class="sd">    @param hybrid_sys:</span>
<span class="sd">        dynamics of switching modes</span>
<span class="sd">    @param disc_params:</span>
<span class="sd">        discretization parameters</span>
<span class="sd">        passed to `discretize` for each mode.</span>
<span class="sd">        See `discretize` for details.</span>
<span class="sd">        (`dict` keyed by mode)</span>
<span class="sd">    @param plot:</span>
<span class="sd">        save partition images</span>
<span class="sd">    @param show_ts, only_adjacent:</span>
<span class="sd">        options for</span>
<span class="sd">        `AbstractPwa.plot`.</span>
<span class="sd">    @return:</span>
<span class="sd">        abstracted dynamics,</span>
<span class="sd">        some attributes are `dict` keyed by mode</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">disc_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">disc_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">trans_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;discretizing hybrid system&#39;</span><span class="p">)</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hybrid_sys</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
    <span class="n">mode_nums</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">disc_domain_size</span>
    <span class="c1"># discretize each abstraction separately</span>
    <span class="n">abstractions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="mi">30</span> <span class="o">*</span> <span class="s1">&#39;-&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Abstracting mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">absys</span> <span class="o">=</span> <span class="n">discretize</span><span class="p">(</span>
            <span class="n">ppp</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span>
            <span class="o">**</span><span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Mode Abstraction:</span><span class="se">\n</span><span class="si">{</span><span class="n">absys</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">abstractions</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">absys</span>
    <span class="c1"># merge their domains</span>
    <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">ap_labeling</span> <span class="o">=</span> <span class="n">merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Merged partition has: </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s1">, states&#39;</span><span class="p">)</span>
    <span class="c1"># find feasible transitions over merged partition</span>
    <span class="n">trans</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">cont_dyn</span> <span class="o">=</span> <span class="n">hybrid_sys</span><span class="o">.</span><span class="n">dynamics</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">params</span> <span class="o">=</span> <span class="n">disc_params</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">trans</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_transitions</span><span class="p">(</span>
            <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cont_dyn</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">],</span>
            <span class="n">trans_length</span><span class="o">=</span><span class="n">params</span><span class="p">[</span><span class="s1">&#39;trans_length&#39;</span><span class="p">])</span>
    <span class="c1"># merge the abstractions, creating a common TS</span>
    <span class="n">merge_abstractions</span><span class="p">(</span>
        <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
        <span class="n">abstractions</span><span class="p">,</span> <span class="n">modes</span><span class="p">,</span> <span class="n">mode_nums</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">plot</span><span class="p">:</span>
        <span class="n">plot_mode_partitions</span><span class="p">(</span>
            <span class="n">merged_abstr</span><span class="p">,</span> <span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">merged_abstr</span>


<span class="k">def</span> <span class="nf">plot_mode_partitions</span><span class="p">(</span>
        <span class="n">swab</span><span class="p">:</span>
            <span class="n">AbstractSwitched</span><span class="p">,</span>
        <span class="n">show_ts</span><span class="p">:</span>
            <span class="nb">bool</span><span class="p">,</span>
        <span class="n">only_adjacent</span><span class="p">:</span>
            <span class="nb">bool</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save each mode&#39;s partition and final merged partition.&quot;&quot;&quot;</span>
    <span class="n">axs</span> <span class="o">=</span> <span class="n">swab</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">show_ts</span><span class="p">,</span> <span class="n">only_adjacent</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">axs</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;failed to plot the partitions.&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">swab</span><span class="o">.</span><span class="n">modes</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">axs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="o">*</span><span class="n">n</span>
    <span class="c1"># annotate</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axs</span><span class="p">:</span>
        <span class="n">plot_annot</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>
    <span class="c1"># save mode partitions</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">[:</span><span class="n">n</span><span class="p">],</span> <span class="n">swab</span><span class="o">.</span><span class="n">modes</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;merged_</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">.pdf&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="c1"># save merged partition</span>
    <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">mode</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="n">n</span><span class="p">:],</span> <span class="n">swab</span><span class="o">.</span><span class="n">modes</span><span class="p">):</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;part_</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">.pdf&#39;</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">plot_annot</span><span class="p">(</span>
        <span class="n">ax</span><span class="p">:</span>
            <span class="s1">&#39;_mpl.axes.Axes&#39;</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
        <span class="n">tick</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">tick</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_major_ticks</span><span class="p">():</span>
        <span class="n">tick</span><span class="o">.</span><span class="n">label1</span><span class="o">.</span><span class="n">set_fontsize</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;$v_1$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;$v_2$&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontsize</span> <span class="o">+</span> <span class="mi">6</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">merge_abstractions</span><span class="p">(</span>
        <span class="n">merged_abstr</span><span class="p">:</span>
            <span class="n">AbstractSwitched</span><span class="p">,</span>
        <span class="n">trans</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">AbstractPwa</span><span class="p">],</span>
        <span class="n">abstr</span><span class="p">,</span>
        <span class="n">modes</span><span class="p">,</span>
        <span class="n">mode_nums</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct merged transitions.&quot;&quot;&quot;</span>
    <span class="c1"># TODO: check equality of atomic proposition sets</span>
    <span class="n">aps</span> <span class="o">=</span> <span class="n">abstr</span><span class="p">[</span><span class="n">modes</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">atomic_propositions</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;APs: </span><span class="si">{</span><span class="n">aps</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">sys_ts</span> <span class="o">=</span> <span class="n">trs</span><span class="o">.</span><span class="n">FTS</span><span class="p">()</span>
    <span class="c1"># create stats</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">states</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">sys_ts</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="n">sys_ts</span><span class="o">.</span><span class="n">atomic_propositions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">aps</span><span class="p">)</span>
    <span class="c1"># copy AP labels from regions to discrete states</span>
    <span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">states</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ppp2ts</span><span class="p">):</span>
        <span class="n">props</span> <span class="o">=</span>  <span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">props</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">props</span>
    <span class="c1"># create mode actions</span>
    <span class="n">env_actions</span><span class="p">,</span> <span class="n">sys_actions</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">modes</span><span class="p">)</span>
    <span class="n">env_actions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">env_actions</span><span class="p">))</span>
    <span class="n">sys_actions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">sys_actions</span><span class="p">))</span>
    <span class="c1"># no env actions ?</span>
    <span class="k">if</span> <span class="n">mode_nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">actions_per_mode</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="p">{</span><span class="s1">&#39;sys_actions&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">}</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">sys_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">sys_actions</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">mode_nums</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># no sys actions</span>
        <span class="n">actions_per_mode</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="p">{</span><span class="s1">&#39;env_actions&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)}</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">}</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">env_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">env_actions</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">actions_per_mode</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span> <span class="nb">dict</span><span class="p">(</span>
                <span class="n">env_actions</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span>
                <span class="n">sys_actions</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">}</span>
        <span class="n">env_actions</span><span class="p">,</span> <span class="n">sys_actions</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">modes</span><span class="p">)</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">env_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">env_actions</span><span class="p">)</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">sys_actions</span><span class="o">.</span><span class="n">add_from</span><span class="p">(</span><span class="n">sys_actions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
        <span class="n">env_sys_actions</span> <span class="o">=</span> <span class="n">actions_per_mode</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="n">trans</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span>
        <span class="n">sys_ts</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">add_adj</span><span class="p">(</span>
            <span class="n">adj</span> <span class="o">=</span> <span class="n">adj</span><span class="p">,</span>
            <span class="n">adj2states</span> <span class="o">=</span> <span class="n">states</span><span class="p">,</span>
            <span class="o">**</span><span class="n">env_sys_actions</span><span class="p">)</span>
    <span class="n">merged_abstr</span><span class="o">.</span><span class="n">ts</span> <span class="o">=</span> <span class="n">sys_ts</span>
    <span class="n">merged_abstr</span><span class="o">.</span><span class="n">ppp2ts</span> <span class="o">=</span> <span class="n">ppp2ts</span>


<span class="k">def</span> <span class="nf">get_transitions</span><span class="p">(</span>
        <span class="n">abstract_sys</span><span class="p">:</span>
            <span class="n">AbstractSwitched</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">,</span>
        <span class="n">ssys</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">closed_loop</span><span class="p">:</span>
            <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">trans_length</span><span class="p">:</span>
            <span class="nb">int</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find which transitions are feasible in given mode.</span>

<span class="sd">    Used for the candidate transitions of the merged partition.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s1">&#39;checking which transitions remain &#39;</span>
        <span class="s1">&#39;feasible after merging&#39;</span><span class="p">)</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">abstract_sys</span><span class="o">.</span><span class="n">ppp</span>
    <span class="c1"># Initialize matrix for pairs to check</span>
    <span class="n">IJ</span> <span class="o">=</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">trans_length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">trans_length</span><span class="p">:</span>
            <span class="n">IJ</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">IJ</span><span class="p">,</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">IJ</span> <span class="o">=</span> <span class="p">(</span><span class="n">IJ</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Initialize output</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">transitions</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">lil_array</span><span class="p">(</span>
        <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="c1"># Do the abstraction</span>
    <span class="n">n_checked</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_found</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">n_checked</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">IJ</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">IJ</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;checking transition: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> -&gt; </span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">si</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">sj</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="c1"># Use original cell as trans_set</span>
        <span class="n">trans_set</span> <span class="o">=</span> <span class="n">abstract_sys</span><span class="o">.</span><span class="n">ppp2pwa</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">active_subsystem</span> <span class="o">=</span> <span class="n">abstract_sys</span><span class="o">.</span><span class="n">ppp2sys</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">i</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">trans_feasible</span> <span class="o">=</span> <span class="n">_fsb</span><span class="o">.</span><span class="n">is_feasible</span><span class="p">(</span>
            <span class="n">si</span><span class="p">,</span> <span class="n">sj</span><span class="p">,</span> <span class="n">active_subsystem</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span>
            <span class="n">closed_loop</span> <span class="o">=</span> <span class="n">closed_loop</span><span class="p">,</span>
            <span class="n">trans_set</span> <span class="o">=</span> <span class="n">trans_set</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">trans_feasible</span><span class="p">:</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Feasible transition.&#39;</span>
            <span class="n">n_found</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transitions</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1"> Not feasible transition.&#39;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Checked: </span><span class="si">{</span><span class="n">n_checked</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Found: </span><span class="si">{</span><span class="n">n_found</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">n_checked</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;would divide &#39;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="sa">f</span><span class="s1">&#39;Survived merging: </span><span class="si">{</span><span class="nb">float</span><span class="p">(</span><span class="n">n_found</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">n_checked</span><span class="si">}</span><span class="s1"> % &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">transitions</span>


<span class="k">def</span> <span class="nf">multiproc_merge_partitions</span><span class="p">(</span><span class="n">abstractions</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;LOGTIME in #processors parallel merging.</span>

<span class="sd">    Assuming sufficient number of processors.</span>

<span class="sd">    UNDER DEVELOPMENT; function signature may</span>
<span class="sd">    change without notice.</span>
<span class="sd">    Calling will result in `NotImplementedError`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span>


<span class="k">def</span> <span class="nf">merge_partitions</span><span class="p">(</span>
        <span class="n">abstractions</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">AbstractPwa</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="n">AbstractSwitched</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge multiple abstractions.</span>

<span class="sd">    @param abstractions:</span>
<span class="sd">        keyed by mode</span>
<span class="sd">    @return:</span>
<span class="sd">        `(merged_abstraction, ap_labeling)`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">abstractions</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s1">&#39;Abstractions empty, &#39;</span>
            <span class="s1">&#39;nothing to merge.&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># consistency check</span>
    <span class="k">for</span> <span class="n">ab1</span> <span class="ow">in</span> <span class="n">abstractions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">ab2</span> <span class="ow">in</span> <span class="n">abstractions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">ab1</span><span class="o">.</span><span class="n">ppp</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">ab2</span><span class="o">.</span><span class="n">ppp</span>
            <span class="k">if</span> <span class="n">p1</span><span class="o">.</span><span class="n">prop_regions</span> <span class="o">!=</span> <span class="n">p2</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;merge: partitions have &#39;</span>
                    <span class="s1">&#39;different sets of &#39;</span>
                    <span class="s1">&#39;continuous propositions&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">A</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="p">(</span><span class="n">p1</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">b</span> <span class="o">==</span> <span class="n">p2</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;merge: partitions have &#39;</span>
                    <span class="s1">&#39;different domains&#39;</span><span class="p">)</span>
            <span class="c1"># check equality of original PPP partitions</span>
            <span class="k">if</span> <span class="n">ab1</span><span class="o">.</span><span class="n">orig_ppp</span> <span class="o">==</span> <span class="n">ab2</span><span class="o">.</span><span class="n">orig_ppp</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s1">&#39;original partitions happen to be equal&#39;</span><span class="p">)</span>
    <span class="n">init_mode</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">abstractions</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">all_modes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">abstractions</span><span class="p">)</span>
    <span class="n">remaining_modes</span> <span class="o">=</span> <span class="n">all_modes</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">init_mode</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;init mode: </span><span class="si">{</span><span class="n">init_mode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;all modes: </span><span class="si">{</span><span class="n">all_modes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;remaining modes: </span><span class="si">{</span><span class="n">remaining_modes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1"># initialize iteration data</span>
    <span class="n">prev_modes</span> <span class="o">=</span> <span class="p">[</span><span class="n">init_mode</span><span class="p">]</span>
   	<span class="c1"># Create a list of merged-together regions</span>
    <span class="n">ab0</span> <span class="o">=</span> <span class="n">abstractions</span><span class="p">[</span><span class="n">init_mode</span><span class="p">]</span>
    <span class="n">regions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ab0</span><span class="o">.</span><span class="n">ppp</span><span class="p">)</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span><span class="n">init_mode</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">regions</span><span class="p">)))}</span>
    <span class="n">ap_labeling</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">i</span><span class="p">:</span> <span class="n">reg</span><span class="o">.</span><span class="n">props</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">regions</span><span class="p">)}</span>
    <span class="k">for</span> <span class="n">cur_mode</span> <span class="ow">in</span> <span class="n">remaining_modes</span><span class="p">:</span>
        <span class="n">ab2</span> <span class="o">=</span> <span class="n">abstractions</span><span class="p">[</span><span class="n">cur_mode</span><span class="p">]</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">merge_partition_pair</span><span class="p">(</span>
            <span class="n">regions</span><span class="p">,</span> <span class="n">ab2</span><span class="p">,</span> <span class="n">cur_mode</span><span class="p">,</span> <span class="n">prev_modes</span><span class="p">,</span>
            <span class="n">parents</span><span class="p">,</span> <span class="n">ap_labeling</span><span class="p">)</span>
        <span class="n">regions</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">ap_labeling</span> <span class="o">=</span> <span class="n">r</span>
        <span class="n">prev_modes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_mode</span><span class="p">)</span>
    <span class="n">new_list</span> <span class="o">=</span> <span class="n">regions</span>
    <span class="c1"># build adjacency based on spatial adjacencies of</span>
    <span class="c1"># component abstractions.</span>
    <span class="c1"># which justifies the assumed symmetry of part1.adj, part2.adj</span>
	<span class="c1"># Basically, if two regions are either 1) part of the same region in one of</span>
	<span class="c1"># the abstractions or 2) adjacent in one of the abstractions, then the two</span>
	<span class="c1"># regions are adjacent in the switched dynamics.</span>
    <span class="n">n_reg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_list</span><span class="p">)</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_reg</span><span class="p">,</span> <span class="n">n_reg</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">reg_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">reg_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">new_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">]):</span>
            <span class="n">touching</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">abstractions</span><span class="p">:</span>
                <span class="n">pi</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">pj</span> <span class="o">=</span> <span class="n">parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="n">part</span> <span class="o">=</span> <span class="n">abstractions</span><span class="p">[</span><span class="n">mode</span><span class="p">]</span><span class="o">.</span><span class="n">ppp</span>
                <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">pi</span><span class="p">,</span> <span class="n">pj</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">pi</span> <span class="o">==</span> <span class="n">pj</span><span class="p">:</span>
                    <span class="n">touching</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">touching</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">pc</span><span class="o">.</span><span class="n">is_adjacent</span><span class="p">(</span><span class="n">reg_i</span><span class="p">,</span> <span class="n">reg_j</span><span class="p">):</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">adj</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">ppp</span> <span class="o">=</span> <span class="n">PPP</span><span class="p">(</span>
        <span class="n">domain</span><span class="o">=</span><span class="n">ab0</span><span class="o">.</span><span class="n">ppp</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span>
        <span class="n">regions</span><span class="o">=</span><span class="n">new_list</span><span class="p">,</span>
        <span class="n">prop_regions</span><span class="o">=</span><span class="n">ab0</span><span class="o">.</span><span class="n">ppp</span><span class="o">.</span><span class="n">prop_regions</span><span class="p">,</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">adj</span><span class="p">)</span>
    <span class="n">abstraction</span> <span class="o">=</span> <span class="n">AbstractSwitched</span><span class="p">(</span>
        <span class="n">ppp</span><span class="o">=</span><span class="n">ppp</span><span class="p">,</span>
        <span class="n">modes</span><span class="o">=</span><span class="n">abstractions</span><span class="p">,</span>
        <span class="n">ppp2modes</span><span class="o">=</span><span class="n">parents</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">abstraction</span><span class="p">,</span> <span class="n">ap_labeling</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">merge_partition_pair</span><span class="p">(</span>
        <span class="n">old_regions</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">],</span>
        <span class="n">ab2</span><span class="p">:</span>
            <span class="n">AbstractPwa</span><span class="p">,</span>
        <span class="n">cur_mode</span><span class="p">:</span>
            <span class="nb">tuple</span><span class="p">,</span>
        <span class="n">prev_modes</span><span class="p">:</span>
            <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span>
        <span class="n">old_parents</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">,</span>
        <span class="n">old_ap_labeling</span><span class="p">:</span>
            <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span>
            <span class="nb">list</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">,</span>
            <span class="nb">dict</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Merge an Abstraction with the current partition iterate.</span>

<span class="sd">    @param old_regions:</span>
<span class="sd">        A `list` of `Region` that is from either:</span>
<span class="sd">        1. The ppp of the first (initial) `AbstractPwa` to be merged.</span>
<span class="sd">        2. A list of already-merged regions</span>
<span class="sd">    @param ab2:</span>
<span class="sd">        Abstracted piecewise affine dynamics to be merged into the</span>
<span class="sd">    @param cur_mode:</span>
<span class="sd">        mode to be merged</span>
<span class="sd">    @param prev_modes:</span>
<span class="sd">        list of modes that have already been merged together</span>
<span class="sd">    @param old_parents:</span>
<span class="sd">        dict of modes that have already been merged to dict of</span>
<span class="sd">        indices of new regions to indices of regions.</span>

<span class="sd">        A `dict` that maps each mode to</span>
<span class="sd">        a `list` of region indices in the list</span>
<span class="sd">        `old_regions` or</span>
<span class="sd">        a `dict` that maps region indices to</span>
<span class="sd">        regions in the original ppp for that mode</span>
<span class="sd">    @param old_ap_labeling:</span>
<span class="sd">        dict of states of already-merged modes to sets of</span>
<span class="sd">        propositions for each state</span>
<span class="sd">    @return: the following:</span>
<span class="sd">        - `new_list`, list of new regions</span>
<span class="sd">        - `parents`, same as input param `old_parents`, except that it</span>
<span class="sd">          includes the mode that was just merged and for list of regions in</span>
<span class="sd">          return value `new_list`</span>
<span class="sd">        - `ap_labeling`, same as input param `old_ap_labeling`, except that it</span>
<span class="sd">          includes the mode that was just merged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;merging partitions&#39;</span><span class="p">)</span>
    <span class="n">part2</span> <span class="o">=</span> <span class="n">ab2</span><span class="o">.</span><span class="n">ppp</span>
    <span class="n">modes</span> <span class="o">=</span> <span class="n">prev_modes</span> <span class="o">+</span> <span class="p">[</span><span class="n">cur_mode</span><span class="p">]</span>
    <span class="n">new_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="p">{</span><span class="n">mode</span><span class="p">:</span><span class="nb">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">}</span>
    <span class="n">ap_labeling</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_regions</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">part2</span><span class="p">)):</span>
            <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span>
                <span class="n">old_regions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">part2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">rc</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">cheby_ball</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="c1"># no intersection ?</span>
            <span class="k">if</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;merging region: A</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">, with: B</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># if Polytope, make it Region</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">isect</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="n">Region</span><span class="p">([</span><span class="n">isect</span><span class="p">])</span>
            <span class="c1"># label the Region with propositions</span>
            <span class="n">isect</span><span class="o">.</span><span class="n">props</span> <span class="o">=</span> <span class="n">old_regions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">props</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">new_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">new_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">isect</span><span class="p">)</span>
            <span class="c1"># keep track of parents</span>
            <span class="k">for</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">prev_modes</span><span class="p">:</span>
                <span class="n">parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_parents</span><span class="p">[</span><span class="n">mode</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">parents</span><span class="p">[</span><span class="n">cur_mode</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
            <span class="c1"># union of AP labels from parent states</span>
            <span class="n">ap_label_1</span> <span class="o">=</span> <span class="n">old_ap_labeling</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ap_label_2</span> <span class="o">=</span> <span class="n">ab2</span><span class="o">.</span><span class="n">ts</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="s1">&#39;ap&#39;</span><span class="p">]</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;AP label 1: </span><span class="si">{</span><span class="n">ap_label_1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;AP label 2: </span><span class="si">{</span><span class="n">ap_label_2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="c1"># original partitions may be</span>
            <span class="c1"># different if `_p2p.pwa_partition` used</span>
            <span class="c1"># but must originate from same</span>
            <span class="c1"># initial partition,</span>
            <span class="c1"># i.e., have same continuous propositions,</span>
            <span class="c1"># checked above</span>
            <span class="c1">#</span>
            <span class="c1"># so no two intersecting regions can</span>
            <span class="c1"># have different AP labels,</span>
            <span class="c1"># checked here</span>
            <span class="k">if</span> <span class="n">ap_label_1</span> <span class="o">!=</span> <span class="n">ap_label_2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
                    <span class="s1">&#39;Inconsistent AP labels between &#39;</span>
                    <span class="s1">&#39;intersecting regions of </span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;partitions of switched system.&#39;</span><span class="p">)</span>
            <span class="n">ap_labeling</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">ap_label_1</span>
    <span class="k">return</span> <span class="n">new_list</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">ap_labeling</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../../index.html">TuLiP 1.4.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">abstract.discretization</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2010-2017, California Institute of Technology.
      Last updated on 17 April 2024.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.3.1.
    </div>
  </body>
</html>